/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /gh/SamuelVanEgmond/Smooth-Voxels@2.2.0/dist/smoothvoxels.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";var SVOX={colorManagement:!0,showWarnings:!0,clampColors:!1,models:{},MATSTANDARD:"standard",MATBASIC:"basic",MATLAMBERT:"lambert",MATPHONG:"phong",MATPHYSICAL:"physical",MATMATCAP:"matcap",MATTOON:"toon",MATNORMAL:"normal",BOUNDS:"bounds",FIT:"fit",FILL:"fill",FLAT:"flat",QUAD:"quad",SMOOTH:"smooth",BOTH:"both",SIDES:"sides",FRONT:"front",BACK:"back",DOUBLE:"double",_FACES:["nx","px","ny","py","nz","pz"],_VERTICES:{nx:[{x:0,y:0,z:0},{x:0,y:1,z:0},{x:0,y:1,z:1},{x:0,y:0,z:1}],px:[{x:1,y:0,z:1},{x:1,y:1,z:1},{x:1,y:1,z:0},{x:1,y:0,z:0}],ny:[{x:0,y:0,z:0},{x:0,y:0,z:1},{x:1,y:0,z:1},{x:1,y:0,z:0}],py:[{x:0,y:1,z:1},{x:0,y:1,z:0},{x:1,y:1,z:0},{x:1,y:1,z:1}],nz:[{x:1,y:0,z:0},{x:1,y:1,z:0},{x:0,y:1,z:0},{x:0,y:0,z:0}],pz:[{x:0,y:0,z:1},{x:0,y:1,z:1},{x:1,y:1,z:1},{x:1,y:0,z:1}]},_FACEOFFSETS:{nx:{x:-1,y:0,z:0},px:{x:1,y:0,z:0},ny:{x:0,y:-1,z:0},py:{x:0,y:1,z:0},nz:{x:0,y:0,z:-1},pz:{x:0,y:0,z:1}},_FACEUVDEFS:{nx:{order:[0,1,2,3],udir:"z",vdir:"y",uminbound:"minZ",vminbound:"minY",usign:1,vsign:1,cubeu:0,cubev:0,top:{x:0,y:1,z:0},right:{x:0,y:0,z:1},bottom:{x:0,y:-1,z:0},left:{x:0,y:0,z:-1}},px:{order:[3,2,1,0],udir:"z",vdir:"y",uminbound:"maxZ",vminbound:"minY",usign:-1,vsign:1,cubeu:.5,cubev:0,top:{x:0,y:1,z:0},right:{x:0,y:0,z:1},bottom:{x:0,y:-1,z:0},left:{x:0,y:0,z:-1}},ny:{order:[0,1,2,3],udir:"x",vdir:"z",uminbound:"minX",vminbound:"minZ",usign:1,vsign:1,cubeu:.75,cubev:.5,top:{x:0,y:0,z:1},right:{x:1,y:0,z:0},bottom:{x:0,y:0,z:-1},left:{x:-1,y:0,z:0}},py:{order:[1,0,3,2],udir:"x",vdir:"z",uminbound:"minX",vminbound:"maxZ",usign:1,vsign:-1,cubeu:.25,cubev:.5,top:{x:0,y:0,z:1},right:{x:1,y:0,z:0},bottom:{x:0,y:0,z:-1},left:{x:-1,y:0,z:0}},nz:{order:[3,2,1,0],udir:"x",vdir:"y",uminbound:"maxX",vminbound:"minY",usign:-1,vsign:1,cubeu:.75,cubev:0,top:{x:0,y:1,z:0},right:{x:1,y:0,z:0},bottom:{x:0,y:-1,z:0},left:{x:-1,y:0,z:0}},pz:{order:[0,1,2,3],udir:"x",vdir:"y",uminbound:"minX",vminbound:"minY",usign:1,vsign:1,cubeu:.25,cubev:0,top:{x:0,y:1,z:0},right:{x:1,y:0,z:0},bottom:{x:0,y:-1,z:0},left:{x:-1,y:0,z:0}}},_AONEIGHBORS:{nx:{top:{x:-1,y:1,z:0,faces:["ny"]},topRight:{x:-1,y:1,z:1,faces:["ny","nz"]},right:{x:-1,y:0,z:1,faces:["nz"]},bottomRight:{x:-1,y:-1,z:1,faces:["nz","py"]},bottom:{x:-1,y:-1,z:0,faces:["py"]},bottomLeft:{x:-1,y:-1,z:-1,faces:["py","pz"]},left:{x:-1,y:0,z:-1,faces:["pz"]},topLeft:{x:-1,y:1,z:-1,faces:["pz","ny"]}},px:{top:{x:1,y:1,z:0,faces:["ny"]},topRight:{x:1,y:1,z:-1,faces:["ny","pz"]},right:{x:1,y:0,z:-1,faces:["pz"]},bottomRight:{x:1,y:-1,z:-1,faces:["pz","py"]},bottom:{x:1,y:-1,z:0,faces:["py"]},bottomLeft:{x:1,y:-1,z:1,faces:["py","nz"]},left:{x:1,y:0,z:1,faces:["nz"]},topLeft:{x:1,y:1,z:1,faces:["nz","ny"]}},ny:{top:{x:0,y:-1,z:1,faces:["nz"]},topRight:{x:1,y:-1,z:1,faces:["nz","nx"]},right:{x:1,y:-1,z:0,faces:["nx"]},bottomRight:{x:1,y:-1,z:-1,faces:["nx","pz"]},bottom:{x:0,y:-1,z:-1,faces:["pz"]},bottomLeft:{x:-1,y:-1,z:-1,faces:["pz","px"]},left:{x:-1,y:-1,z:0,faces:["px"]},topLeft:{x:-1,y:-1,z:1,faces:["px","nz"]}},py:{top:{x:0,y:1,z:-1,faces:["pz"]},topRight:{x:1,y:1,z:-1,faces:["pz","nx"]},right:{x:1,y:1,z:0,faces:["nx"]},bottomRight:{x:1,y:1,z:1,faces:["nx","nz"]},bottom:{x:0,y:1,z:1,faces:["nz"]},bottomLeft:{x:-1,y:1,z:1,faces:["nz","px"]},left:{x:-1,y:1,z:0,faces:["px"]},topLeft:{x:-1,y:1,z:-1,faces:["px","pz"]}},nz:{top:{x:0,y:1,z:-1,faces:["ny"]},topRight:{x:-1,y:1,z:-1,faces:["ny","px"]},right:{x:-1,y:0,z:-1,faces:["px"]},bottomRight:{x:-1,y:-1,z:-1,faces:["px","py"]},bottom:{x:0,y:-1,z:-1,faces:["py"]},bottomLeft:{x:1,y:-1,z:-1,faces:["py","nx"]},left:{x:1,y:0,z:-1,faces:["nx"]},topLeft:{x:1,y:1,z:-1,faces:["nx","ny"]}},pz:{top:{x:0,y:1,z:1,faces:["ny"]},topRight:{x:1,y:1,z:1,faces:["ny","nx"]},right:{x:1,y:0,z:1,faces:["nx"]},bottomRight:{x:1,y:-1,z:1,faces:["nx","py"]},bottom:{x:0,y:-1,z:1,faces:["py"]},bottomLeft:{x:-1,y:-1,z:1,faces:["py","px"]},left:{x:-1,y:0,z:1,faces:["px"]},topLeft:{x:-1,y:1,z:1,faces:["px","ny"]}}},htmlEscape:function(e){return e.replace(/&/g,"&amp").replace(/>/g,"&gt").replace(/</g,"&lt").replace(/\n/g,"<br>")},logError:function(e){let t=e.name+": "+e.message.replace("(__playground)","").trim(),r=document.getElementById("svoxerrors");r&&(r.innerHTML+=SVOX.htmlEscape(t)+"<br>"),console.error(`SVOX ${t}`)},logWarning:function(e,t){let r=e.name+": "+e.message.replace("(__playground)","").trim();if(this.showWarnings){let e=document.getElementById("svoxwarnings");e&&(e.innerHTML+=SVOX.htmlEscape(r)+"<br>")}console.warn(`SVOX ${t?"("+t+") ":""}${r}`)},logInfo:function(e,t){let r=e.name+": "+e.message;console.info(`SVOX ${t?"("+t+") ":""}${r}`)}};class Planar{static parse(e){if(!e)return;if("object"==typeof e)return{nx:e.nx,x:e.x,px:e.px,ny:e.ny,y:e.y,py:e.py,nz:e.nz,z:e.z,pz:e.pz,active:e.nx||e.x||e.px||e.ny||e.y||e.py||e.nz||e.z||e.pz};if(" "!==(e=" "+(e||"").toLowerCase())&&!/^(?!$)(\s+(?:none|-x|x|\+x|-y|y|\+y|-z|z|\+z|\s))+\s*$/.test(e))throw{name:"SyntaxError",message:`Planar expression '${e}' is only allowed to be 'none' or contain -x x +x -y y +y -z z +z.`};let t=e.includes("none"),r={nx:!t&&e.includes("-x"),x:!t&&e.includes(" x"),px:!t&&e.includes("+x"),ny:!t&&e.includes("-y"),y:!t&&e.includes(" y"),py:!t&&e.includes("+y"),nz:!t&&e.includes("-z"),z:!t&&e.includes(" z"),pz:!t&&e.includes("+z")};return r.active=r.nx||r.x||r.px||r.ny||r.y||r.py||r.nz||r.z||r.pz,r}static toString(e){if(!e)return;let t="";return e.nx||e.x||e.px||e.ny||e.y||e.py||e.nz||e.z||e.pz?t+=(e.nx?" -x":"")+(e.x?" x":"")+(e.px?" +x":"")+(e.ny?" -y":"")+(e.y?" y":"")+(e.py?" +y":"")+(e.nz?" -z":"")+(e.z?" z":"")+(e.pz?" +z":""):t+="none",t.trim()}static combine(e,t,r){if(!e&&!t)return r;if(!e)return t;if(!t)return e;if(e===t)return e;let a={nx:e.nx||t.nx,x:e.x||t.x,px:e.px||t.px,ny:e.ny||t.ny,y:e.y||t.y,py:e.py||t.py,nz:e.nz||t.nz,z:e.z||t.z,pz:e.pz||t.pz};return a.active=a.nx||a.x||a.px||a.ny||a.y||a.py||a.nz||a.z||a.pz,a}}class BoundingBox{get size(){return this.minX>this.maxX?{x:0,y:0,z:0}:{x:this.maxX-this.minX+1,y:this.maxY-this.minY+1,z:this.maxZ-this.minZ+1}}constructor(e){e?this.copy(e):this.reset()}isValid(){return this.minX<=this.maxX&&this.minY<=this.maxY&&this.minZ<=this.maxZ}reset(){this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.minZ=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY,this.maxZ=Number.NEGATIVE_INFINITY}set(e,t,r){this.minX=Math.min(this.minX,e),this.minY=Math.min(this.minY,t),this.minZ=Math.min(this.minZ,r),this.maxX=Math.max(this.maxX,e),this.maxY=Math.max(this.maxY,t),this.maxZ=Math.max(this.maxZ,r)}copy(e){this.minX=e.minX,this.minY=e.minY,this.minZ=e.minZ,this.maxX=e.maxX,this.maxY=e.maxY,this.maxZ=e.maxZ}getCenter(){return this.isValid()?{x:(this.minX+this.maxX)/2,y:(this.minY+this.maxY)/2,z:(this.minZ+this.maxZ)/2}:{x:0,y:0,z:0}}get sizeX(){return this.maxX-this.minX}get sizeY(){return this.maxY-this.minY}get sizeZ(){return this.maxZ-this.minZ}}class Voxel{constructor(e,t){this.color=e,this.material=e.material,this.faces={},this.visible=!0,this.group=t??e.material.group}dispose(){this.color=null,this.material=null,this.faces=null}}class VoxelMatrix{get minX(){return this.bounds.minX}get minY(){return this.bounds.minY}get minZ(){return this.bounds.minZ}get maxX(){return this.bounds.maxX}get maxY(){return this.bounds.maxY}get maxZ(){return this.bounds.maxZ}get size(){return this.minX>this.maxX?{x:0,y:0,z:0}:{x:this.maxX-this.minX+1,y:this.maxY-this.minY+1,z:this.maxZ-this.minZ+1}}get count(){return this._count}constructor(){this.bounds=new BoundingBox,this._voxels={},this._count=0,this.prepareForWrite()}reset(){this.forEach((function(e){e.reset}),this,!0),this.bounds.reset(),this._voxels={},this._count=0}setVoxel(e,t,r,a){if(!(a instanceof Voxel))throw new Error("setVoxel requires a Voxel set to an existing color of a material of this model.");this.bounds.set(e,t,r),a.material.bounds.set(e,t,r),a.x=e,a.y=t,a.z=r;let o=this._voxels[a.group.id];o||(o=this._voxels[a.group.id]=[]);let s=(e+1024>>4)+(t+1024>>4<<10)+(r+1024>>4<<20),i=o[s];i||(i=o[s]=[]);let n=(e+1024&15)+((t+1024&15)<<4)+((r+1024&15)<<8);i[n]||this._count++,i[n]=a}clearVoxel(e,t,r,a){if(!a)throw{name:"Error",message:"clearVoxel(x, y, z, groupId) must be called with a groupId"};let o=this._voxels[a];if(o){let a=o[(e+1024>>4)+(t+1024>>4<<10)+(r+1024>>4<<20)];if(a){let o=(e+1024&15)+((t+1024&15)<<4)+((r+1024&15)<<8);a[o]&&(this._count--,a[o]=null)}}}getVoxel(e,t,r,a){if(!a)throw{name:"Error",message:"getVoxel(x, y, z, groupId) must be called with a groupId"};let o=this._voxels[a];if(o){let a=o[(e+1024>>4)+(t+1024>>4<<10)+(r+1024>>4<<20)];if(a){let o=a[(e+1024&15)+((t+1024&15)<<4)+((r+1024&15)<<8)];if(o)return o}}return null}getVoxelForAnyGroup(e,t,r){let a=(e+1024>>4)+(t+1024>>4<<10)+(r+1024>>4<<20),o=(e+1024&15)+((t+1024&15)<<4)+((r+1024&15)<<8);for(const e in this._voxels){let t=this._voxels[e]?.[a]?.[o];if(t)return t}return null}forEach(e,t,r=!0){let a=[];for(const o in this._voxels){let s=this._voxels[o];for(let o in s){let i=s[o];for(let o in i){let s=i[o];if(s&&(!r||s.visible)){if(a[0]=s,!0===e.apply(t,a))return}}}}}forEachInGroup(e,t,r,a=!0){let o=[],s=this._voxels[e];for(let e in s){let i=s[e];for(let e in i){let s=i[e];if(s&&(!a||s.visible)){if(o[0]=s,!0===t.apply(r,o))return}}}}forEachInBoundary(e,t){let r=[];for(let a=this.bounds.minZ;a<=this.bounds.maxZ;a++)for(let o=this.bounds.minY;o<=this.bounds.maxY;o++)for(let s=this.bounds.minX;s<=this.bounds.maxX;s++){for(const i in this._voxels)if(r[0]=this.getVoxel(s,o,a,i),r[0]){if(!0===e.apply(t,r))return;break}if(!r[0]){if(!0===e.apply(t,r))return}r[0]=null}}prepareForWrite(){this.bounds.reset(),this._count=0,this.forEach((function(e){this.setVoxel(e.x,e.y,e.z,e),this._count++}),this)}}class VertexMatrix{constructor(e){this.model=e,this._vertices={}}createVertex(e,t,r){let a=SVOX._VERTICES[t][r],o=e.x+a.x,s=e.y+a.y,i=e.z+a.z,n=e.material,l=this._isVertexPlanar(this.model.voxels,e,o,s,i,n.flatten,this.model.flatten),c=this._isVertexPlanar(this.model.voxels,e,o,s,i,n.clamp,this.model.clamp),d=this.getVertex(o,s,i,e.group.id);return d?(d.colors.push(e.color),d.flatten.x=d.flatten.x||l.x,d.flatten.y=d.flatten.y||l.y,d.flatten.z=d.flatten.z||l.z,d.clamp.x=d.clamp.x||c.x,d.clamp.y=d.clamp.y||c.y,d.clamp.z=d.clamp.z||c.z,n.deform?d.deform&&this._getDeformIntegral(n.deform)<this._getDeformIntegral(d.deform)&&(d.deform=n.deform):d.deform=null,n.warp?d.warp&&(n.warp.amplitude<d.warp.amplitude||n.warp.amplitude===d.warp.amplitude&&n.warp.frequency>d.warp.frequency)&&(d.warp=n.warp):d.warp=null,n.scatter?d.scatter&&Math.abs(n.scatter)<Math.abs(d.scatter)&&(d.scatter=n.scatter):d.scatter=null,d.faces[t]=!0):(d={x:o,y:s,z:i,newX:0,newY:0,newZ:0,newSet:!1,links:[],nrOfClampedLinks:0,group:e.group,colors:[e.color],deform:n.deform,warp:n.warp,scatter:n.scatter,flatten:l,clamp:c,equidistant:void 0,faces:{},type:SVOX.VNOTSET},d.faces[t]=!0,this._setVertex(o,s,i,d)),d}_setVertex(e,t,r,a){a.x=e,a.y=t,a.z=r;let o=this._vertices[a.group.id];o||(o=this._vertices[a.group.id]=[]);let s=(e+1024>>4)+(t+1024>>4<<10)+(r+1024>>4<<20),i=o[s];i||(i=o[s]=[]),i[(e+1024&15)+((t+1024&15)<<4)+((r+1024&15)<<8)]=a}getVertex(e,t,r,a){if(!a)throw{name:"Error",message:"getVertex(x, y, z, groupId) must be called with a groupId"};let o=this._vertices[a];if(o){let a=o[(e+1024>>4)+(t+1024>>4<<10)+(r+1024>>4<<20)];if(a){return a[(e+1024&15)+((t+1024&15)<<4)+((r+1024&15)<<8)]}}return null}forEach(e,t){let r=[];for(const a in this._vertices){let o=this._vertices[a];for(let a in o){let s=o[a];for(let a in s)r[0]=s[a],e.apply(t,r)}}}_isVertexPlanar(e,t,r,a,o,s,i){let n=s,l=t.material.bounds;n||(n=i,l=e.bounds);let c={x:!1,y:!1,z:!1};return n&&(c.x=n.x||n.nx&&r<l.minX+.5||n.px&&r>l.maxX+.5,c.y=n.y||n.ny&&a<l.minY+.5||n.py&&a>l.maxY+.5,c.z=n.z||n.nz&&o<l.minZ+.5||n.pz&&o>l.maxZ+.5),c}_getDeformIntegral(e){return 1===e.damping?e.strength*(e.count+1):e.strength*(1-Math.pow(e.damping,e.count+1))/(1-e.damping)}}class TextureList{constructor(){this._textures=[]}createTexture(e,t){if(!e.id)throw{name:"SyntaxError",message:`(${t}) Mandatory property 'id' missing in texture`};this._textures.find((t=>t.id===e.id))&&SVOX.logWarning({name:"ModelWarning",message:`(${t}) Duplicate texture id '${e.id}' found.`});let r=TextureReader.read(e,t);return this._textures.push(r),r}get length(){return this._textures.length}getById(e){let t=this._textures.find((t=>t.id===e));if(!t)throw{name:"SyntaxError",message:`Texture with id '${e}' does not exist`};return t}forEach(e,t){this._textures.forEach(e,t)}}class LightList{constructor(){this._lights=[]}createLight(e,t){let r=LightReader.read(e,t);return this._lights.push(r),r}get length(){return this._lights.length}forEach(e,t){this._lights.forEach(e,t)}get visible(){return this._lights.some((e=>0!==e.size))}}class GroupList{constructor(){this._groups=[]}createGroup(e,t){delete e.bounds,delete e.vertexBounds;let r=GroupReader.read(e,t);if(this._groups.find((t=>t.id===e.id)))throw{name:"ModelError",message:`(${t}) Duplicate group id '${e.id}' found.`};return r.bounds=new BoundingBox,r.vertexBounds=new BoundingBox,this._groups.push(r),r}get length(){return this._groups.length}getById(e){let t=this._groups.find((t=>t.id===e));if(!t)throw{name:"SyntaxError",message:`Group with id '${e}' does not exist`};return t}sort(){this._groups.sort((function(e,t){return e.group?t.group?e.id===t.group?-1:e.group===t.id?1:0:1:-1}))}removePrefabs(){this._groups=this._groups.filter((e=>!e.prefab))}forEach(e,t){this._groups.forEach(e,t)}}const clamp=(e,t,r)=>Math.min(Math.max(e,t),r);class Color{static fromHex(e,t){let r=new Color;return r._set(e),r.id=t,r.exId=null,r.count=0,r}static fromRgb(e,t,r,a){e=Math.round(255*clamp(e,0,1)),t=Math.round(255*clamp(t,0,1)),r=Math.round(255*clamp(r,0,1));let o="#"+(e<16?"0":"")+e.toString(16)+(t<16?"0":"")+t.toString(16)+(r<16?"0":"")+r.toString(16);return Color.fromHex(o,a)}clone(){let e=new Color;return e._color=this._color,e.r=this.r,e.g=this.g,e.b=this.b,e._material=this._material,e}multiply(e){return e instanceof Color?Color.fromRgb(this.r*e.r,this.g*e.g,this.b*e.b):Color.fromRgb(this.r*e,this.g*e,this.b*e)}normalize(){let e=Math.sqrt(this.r*this.r+this.g*this.g+this.b*this.b);return this.multiply(1/e)}add(...e){let t=this.r+e.reduce(((e,t)=>e+t.r),0),r=this.g+e.reduce(((e,t)=>e+t.g),0),a=this.b+e.reduce(((e,t)=>e+t.b),0);return Color.fromRgb(t,r,a)}_setMaterial(e){if(void 0!==this._material)throw"A Color can only be added once.";this._material=e,this.count=0}get material(){return this._material}_set(e){let t=e;if(("string"==typeof t||t instanceof String)&&(t=t.trim().toUpperCase(),t.match(/^#?([0-9a-fA-F]{3}|#?[0-9a-fA-F]{6})$/))){t=t.replace("#",""),this._color="#"+t,3===t.length&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]);let e=parseInt(t,16);return this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,void(this.b=(255&e)/255)}throw{name:"SyntaxError",message:`Color ${e} is not a hexadecimal color of the form #RGB or #RRGGBB.`}}toString(){return this._color}}class BaseMaterial{constructor(e){this._settings=e,this._baseId=JSON.stringify(e),this.index=0,this._colors=[]}get baseId(){return this._baseId}get settings(){return this._settings}get colors(){return this._colors}get colorCount(){return this._colors.length}get colorUsageCount(){return this._colors.reduce(((e,t)=>e+t.count),0)}get hasMap(){for(const e in this._settings)if("envmap"!==e&&("map"===e||e.endsWith("Map"))&&this._settings[e])return!0;return!1}}class Material{constructor(e,t){this._settings=t,this._baseMaterial=e;let r=this._settings.colors;this._settings.colors=[],r.forEach((function(e){this.addColor(e)}),this),this.bounds=new BoundingBox}get settings(){return this._settings}get type(){return this._settings.type}get baseMaterial(){return this._baseMaterial}get baseId(){return this._baseMaterial.baseId}get index(){return this._baseMaterial.index}get lighting(){return this._settings.lighting}get lights(){return this._settings.lights}get castShadow(){return this._settings.castShadow}get receiveShadow(){return this._settings.receiveShadow}get fade(){return this._settings.fade}get opacity(){return this._settings.opacity}get transparent(){return this._settings.transparent}get wireframe(){return this._settings.wireframe}get simplify(){return this._settings.simplify}get side(){return this._settings.side}get deform(){return this._settings.deform}get warp(){return this._settings.warp}get scatter(){return this._settings.scatter}get flatten(){return this._settings.flatten}get clamp(){return this._settings.clamp}get skip(){return this._settings.skip}get hide(){return this._settings.hide}get ao(){return this._settings.ao}get quickAo(){return this._settings.quickAo}get aoSides(){return this._settings.aoSides}get shell(){return this._settings.shell}get data(){return this._settings.data}get colors(){return this._settings.colors}get colorCount(){return this._settings.colors.length}get colorUsageCount(){return this._settings.colors.reduce(((e,t)=>e+t.count),0)}addColorHex(e,t){return this.addColor(Color.fromHex(e,t))}addColorRGB(e,t,r,a){return this.addColor(Color.fromRgb(e,t,r,a))}addColor(e){if(!(e instanceof Color))throw"addColor requires a Color object, e.g. material.addColor(Color.fromHex('#FFFFFF'))";return e._setMaterial(this),this._settings.colors.push(e),this._baseMaterial._colors.push(e),e}}class MaterialList{constructor(){this.baseMaterials=[],this.materials=[]}createMaterial(e,t,r,a){let o=MaterialReader.read(r,t,a),s=o.base,i=(o.baseId,new BaseMaterial(s)),n=i.baseId,l=this.baseMaterials.find((e=>e.baseId===n));l?i=l:this.baseMaterials.push(i);let c=new Material(i,o);return c.group=e.groups.getById(o.group),this.materials.push(c),c}forEach(e,t,r){r?this.baseMaterials.foreach(e,t):this.materials.forEach(e,t)}find(e){return this.materials.find(e)}findColorById(e){let t=null;return this.forEach((function(r){t||(t=r.colors.find((t=>t.id===e)))}),this),t}findColorByExId(e){let t=null;return this.forEach((function(r){t||(t=r.colors.find((t=>t.exId===e)))}),this),t}}class Model{constructor(e){this._settings=e,this.textures=new TextureList,this.lights=new LightList,this.groups=new GroupList,this.materials=new MaterialList,this.voxels=new VoxelMatrix,this.vertices=new VertexMatrix(this)}get settings(){return this._settings}get name(){return this._settings.name}get size(){return this.voxels.size}get scale(){return this._settings.scale}get rotation(){return this._settings.rotation}get position(){return this._settings.position}get simplify(){return this._settings.simplify}get resize(){return this._settings.resize}get shape(){return this._settings.shape}get wireframe(){return this._settings.wireframe}get origin(){return this._settings.origin}get flatten(){return this._settings.flatten}get clamp(){return this._settings.clamp}get skip(){return this._settings.skip}get hide(){return this._settings.hide}get tile(){return this._settings.tile}get shape(){return this._settings.shape}get scaleYX(){return this._settings.scaleYX}get scaleZX(){return this._settings.scaleZX}get scaleXY(){return this._settings.scaleXY}get scaleZY(){return this._settings.scaleZY}get scaleXZ(){return this._settings.scaleXZ}get scaleYZ(){return this._settings.scaleYZ}get rotateX(){return this._settings.rotateX}get rotateY(){return this._settings.rotateY}get rotateZ(){return this._settings.rotateZ}get translateYX(){return this._settings.translateYX}get translateZX(){return this._settings.translateZX}get translateXY(){return this._settings.translateXY}get translateZY(){return this._settings.translateZY}get translateXZ(){return this._settings.translateXZ}get translateYZ(){return this._settings.translateYZ}get ao(){return this._settings.ao}get quickAo(){return this._settings.quickAo}get aoSides(){return this._settings.aoSides}get aoSamples(){return this._settings.aoSamples}get shadowQuality(){return this._settings.shadowQuality}get data(){return this._settings.data}get shell(){return this._settings.shell}get improveNonManifold(){return this._settings.improveNonManifold}prepareForWrite(e){this.settings.size=this.size,!1!==e&&(e=!0),this.materials.forEach((function(e){e.bounds.reset(),e.colors.forEach((function(e){e.count=0}),this)}),this),this.shell&&this.shell.forEach((function(e){e.color.count++}),this),this.materials.forEach((function(e){e.shell&&e.shell.forEach((function(e){e.color.count++}),this)}),this),this.lights.visible&&(this.materials.materials[0].colors[0].count=1),this.voxels.prepareForWrite(),e&&this.voxels.forEach((function(e){e.color.count++})),this._determineColorIds()}_determineColorIds(){let e=[],t={};this.materials.forEach((function(r){r.colors.forEach((function(r){e.push(r),t[r.id]=r.id}))})),e.sort((function(e,t){return t.count-e.count}));let r=0;for(let a=0;a<e.length;a++)if(!e[a].id){let o;do{o=this._colorIdForIndex(r++)}while(t[o]);t[o]=o,e[a].id=o}}_colorIdForIndex(e){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZ",r="";do{let a=e%26;r=t[a]+r.toLowerCase(),(e=(e-a)/26)<26&&(t="#ABCDEFGHIJKLMNOPQRSTUVWXYZ")}while(e>0);return r}determineBoundsForAllGroups(e=!1){this.voxels.bounds.reset(),this.vertexBounds=this.vertexBounds??new BoundingBox,this.vertexBounds.reset(),this.groups.forEach((function(e){e.bounds.reset(),e.vertexBounds.reset(),e.vertexOffset=null,e.vertexRescale=null}),this),this.voxels.forEach((function(t){this.voxels.bounds.set(t.x,t.y,t.z),t.group.bounds.set(t.x,t.y,t.z),t.material.group.bounds.set(t.x,t.y,t.z);for(let r in t.faces){let a=t.faces[r];if(!a.hidden||!e)for(let e=0;e<4;e++){let t=a.vertices[e];t.group.vertexBounds.set(t.x,t.y,t.z),this.vertexBounds.set(t.x,t.y,t.z)}}}),this,!0),this.voxels.bounds.isValid()?this.voxels.bounds.set(this.voxels.bounds.maxX+1,this.voxels.bounds.maxY+1,this.voxels.bounds.maxZ+1):this.voxels.bounds.set(0,0,0),this.groups.forEach((function(t){if(t.bounds.isValid()?t.bounds.set(t.bounds.maxX+1,t.bounds.maxY+1,t.bounds.maxZ+1):(t.bounds.reset(),t.bounds.set(0,0,0)),t.vertexBounds.isValid()||t.vertexBounds.copy(t.bounds),e){if(t.resize===SVOX.BOUNDS)t.vertexRescale={x:1,y:1,z:1};else if(t.resize===SVOX.FIT){let e=(t.bounds.maxX-t.bounds.minX)/(t.vertexBounds.maxX-t.vertexBounds.minX),r=(t.bounds.maxY-t.bounds.minY)/(t.vertexBounds.maxY-t.vertexBounds.minY),a=(t.bounds.maxZ-t.bounds.minZ)/(t.vertexBounds.maxZ-t.vertexBounds.minZ),o=Math.min(e,r,a);t.vertexRescale={x:o,y:o,z:o},t.vertexBounds.copy(t.bounds)}else t.resize===SVOX.FILL?(t.vertexRescale={x:(t.bounds.maxX-t.bounds.minX)/(t.vertexBounds.maxX-t.vertexBounds.minX),y:(t.bounds.maxY-t.bounds.minY)/(t.vertexBounds.maxY-t.vertexBounds.minY),z:(t.bounds.maxZ-t.bounds.minZ)/(t.vertexBounds.maxZ-t.vertexBounds.minZ)},t.vertexBounds.copy(t.bounds)):(t.vertexRescale={x:1,y:1,z:1},t.vertexBounds.copy(t.bounds));let e=t.vertexRescale.x*(t.vertexBounds.maxX-t.vertexBounds.minX)/2,r=t.vertexRescale.y*(t.vertexBounds.maxY-t.vertexBounds.minY)/2,a=t.vertexRescale.z*(t.vertexBounds.maxZ-t.vertexBounds.minZ)/2;t.originOffset={x:0,y:0,z:0},t.origin&&(t.origin.nx&&(t.originOffset.x=e),t.origin.px&&(t.originOffset.x=-e),t.origin.ny&&(t.originOffset.y=r),t.origin.py&&(t.originOffset.y=-r),t.origin.nz&&(t.originOffset.z=a),t.origin.pz&&(t.originOffset.z=-a)),Math.abs(t.originOffset.x)<1e-5&&(t.originOffset.x=0),Math.abs(t.originOffset.y)<1e-5&&(t.originOffset.y=0),Math.abs(t.originOffset.z)<1e-5&&(t.originOffset.z=0)}}),this)}_normalize(e){if(e){let t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);t>0&&(e.x/=t,e.y/=t,e.z/=t)}return e}_isZero(e){return!e||0===e.x&&0===e.y&&0===e.z}}class PropertyParser{static _stringIsNumber(e){return/^-?\d*(\.\d+)?$/.test(e)}static parseName(e,t,r){if(!r)return t;if("*"===r)return r;if(/^([a-zA-Z_][a-zA-Z_0-9]*)$/.test(r))return r;throw{name:"SyntaxError",message:`Invalid name '${r}' for ${e}'.`}}static parseBoolean(e,t,r){if("boolean"==typeof r)return r;let a=r||`${t}`;if("undefined"!==a){if("true"===a)return!0;if("false"===a)return!1;throw{name:"SyntaxError",message:`Invalid boolean value '${r}' for '${e}'. Use true or false.`}}}static parseEnum(e,t,r,a){let o=a||r;if(void 0!==o){if(t.includes(o))return o;throw{name:"SyntaxError",message:`Invalid value '${a}' for '${e}'. Allowed values: ${t.join(", ")}.`}}}static parseColor(e,t,r){let a=r||t;try{return a?Color.fromHex(a):void 0}catch(t){throw{name:t.name,message:`Invalid value for '${e}'. ${t.message}`}}}static parseColorId(e,t){if(t){if(/^[A-Z][a-z]*$/.test(t))return t;throw{name:"SyntaxError",message:`Invalid color Id for '${e}'.`}}}static parsePlanarPoint(e,t,r){let a=Planar.parse(r||t);if(a&&((a.nx?1:0)+(a.x?1:0)+(a.px?1:0)>1||(a.ny?1:0)+(a.y?1:0)+(a.py?1:0)>1||(a.nz?1:0)+(a.z?1:0)+(a.pz?1:0)>1))throw{name:"SyntaxError",message:`Invalid value '${r}' for '${e}'.`};return a}static parsePlanarPlanes(e,t,r){let a=Planar.parse(r||t);return a&&(a.x&&(a.nx=!1,a.px=!1),a.y&&(a.ny=!1,a.py=!1),a.z&&(a.nz=!1,a.pz=!1)),a}static parsePlanarSides(e,t,r){let a=Planar.parse(r||t);return a&&(a.x&&(a.x=!1,a.nx=!0,a.px=!0),a.y&&(a.y=!1,a.ny=!0,a.py=!0),a.z&&(a.z=!1,a.nz=!0,a.pz=!0)),a}static parseFloat(e,t,r){try{return PropertyParser._parseFloatPart(r,t)}catch(t){throw{name:"SyntaxError",message:`Invalid value '${r}' for '${e}'.`}}}static parseXYFloat(e,t,r,a,o){try{let e;if("object"==typeof o){if(e={x:o.x,y:o.y},!Number.isFinite(e.x)||!Number.isFinite(e.y))throw{name:"SyntaxError",message:"There should be two values."}}else if("number"==typeof o){if(!t)throw{name:"SyntaxError",message:"There should be two values."};e={x:o,y:o}}else if(null==o){if(!Number.isFinite(r))return;e={x:r,y:!Number.isFinite(a)&&t?r:a}}else{if(e=o.split(/\s+/).filter((e=>e)),1===e.length&&t&&e.push(e[0]),e.length<2&&Number.isFinite(a)&&e.push(a.toString()),2!==e.length)throw{name:"SyntaxError",message:`There should be ${t?"one or":""} two values.`};e={x:PropertyParser._parseFloatPart(e[0],r),y:PropertyParser._parseFloatPart(e[1],a)}}return e}catch(t){throw{name:"SyntaxError",message:`Invalid value '${o}' for '${e}'. ${t.message?t.message:""}.`}}}static parseXYZInt(e,t,r,a,o,s){let i=PropertyParser.parseXYZFloat(e,t,r,a,o,s);if(i.x!==Math.trunc(i.x)||i.y!==Math.trunc(i.y)||i.z!==Math.trunc(i.z))throw{name:"SyntaxError",message:`'${e}' object must have three integer values.`};return i}static parseXYZFloat(e,t,r,a,o,s){try{let e;if("object"==typeof s){if(e={x:s.x,y:s.y,z:s.z},!Number.isFinite(e.x)||!Number.isFinite(e.y)||!Number.isFinite(e.z))throw{name:"SyntaxError",message:"There should be three values."}}else if("number"==typeof s){if(!t)throw{name:"SyntaxError",message:"There should be three values."};e={x:s,y:s,z:s}}else if(null==s){if(!Number.isFinite(r))return;e={x:r,y:!Number.isFinite(a)&&t?r:a,z:!Number.isFinite(o)&&t?r:o}}else{if(e=s.split(/\s+/).filter((e=>e)),1===e.length&&t&&(e.push(e[0]),e.push(e[0])),e.length<2&&Number.isFinite(a)&&e.push(a.toString()),e.length<3&&Number.isFinite(o)&&e.push(o.toString()),3!==e.length)throw{name:"SyntaxError",message:`There should be ${t?"one or":""} three values.`};e={x:PropertyParser._parseFloatPart(e[0],r),y:PropertyParser._parseFloatPart(e[1],a),z:PropertyParser._parseFloatPart(e[2],o)}}return e}catch(t){throw{name:"SyntaxError",message:`Invalid value '${s}' for '${e}'. ${t.message?t.message:""}.`}}}static parseFloatArray(e,t){try{if(null==t)return;let e=[];if(Array.isArray(t))e=t;else if("number"==typeof t)e=[t];else if("string"==typeof t){let r=t.split(/\s+/).filter((e=>e));for(let t=0;t<r.length;t++)e[t]=PropertyParser._parseFloatPart(r[t])}if(0===e.length)throw{name:"SyntaxError",message:"There should be one or more float values."};return 1===e.length&&e.unshift(0),e}catch(r){throw{name:"SyntaxError",message:`Invalid value '${t}' for '${e}'. ${r.message?r.message:""}.`}}}static _parseFloatPart(e,t){if(null==e)return t;if("number"==typeof e)return e;if("string"==typeof e){let r=e.trim();if(""===r)return t;if(/^-?[0-9]+\.[0-9]+$|^-?[0-9]+$/.test(r))return parseFloat(r)}throw{name:"SyntaxError",message:`Invalid float value '${e}'.`}}static parseString(e,t){return t}static parseAo(e,t){try{if("object"==typeof t){let e=t.color||"#000",r=Math.abs(Number.isFinite(t.maxDistance)?t.maxDistance:1),a=Number.isFinite(t.intensity)?t.intensity:1,o=Number.isFinite(t.angle)?t.angle:70;return o=Math.max(0,Math.min(180,Math.round(o))),{color:e,maxDistance:r,intensity:a,angle:o}}if("string"==typeof t){let r=t;r.startsWith("#")||(r="#000 "+r);let a=r.split(/\s+/);if(a.length<1||a.length>4)throw{name:"SyntaxError",message:"Ao should be of the form [color>] <maxdistance> [<intensity>] [<angle>]."};let o=PropertyParser.parseColor(e,"#000",a[0]),s=Math.abs(PropertyParser._parseFloatPart(a[1],1)),i=PropertyParser._parseFloatPart(a[2],1),n=PropertyParser._parseFloatPart(a[3],70);return n=Math.max(0,Math.min(180,Math.round(n))),{color:o,maxDistance:s,intensity:i,angle:n}}}catch(r){throw{name:"SyntaxError",message:`Invalid value '${t}' for '${e}'. ${r.message?r.message:""}.`}}}static parseQuickAo(e,t){try{if("object"==typeof t){return{color:t.color||"#000",intensity:Number.isFinite(t.intensity)?t.intensity:1}}if("string"==typeof t){let r=t;r.startsWith("#")||(r="#000 "+r);let a=r.split(/\s+/);if(a.length<1||a.length>2)throw{name:"SyntaxError",message:"Quickao should be of the form [<color>] <intensity>."};return{color:PropertyParser.parseColor(e,"#000",a[0]),intensity:PropertyParser._parseFloatPart(a[1],1)}}}catch(r){throw{name:"SyntaxError",message:`Invalid value '${t}' for '${e}'. ${r.message?r.message:""}.`}}}static parseScale(e,t,r){let a=r||t,o=PropertyParser.parseXYZFloat(e,!0,void 0,void 0,void 0,a);if(o&&(0===o.x||0===o.y||0===o.z))throw{name:"SyntaxError",message:`'${e}' cannot be 0 for x, y or z`};return o}static parseDeform(e,t){let r;if("object"==typeof t){r={count:Number.isFinite(t.count)?t.strength:1,strength:Number.isFinite(t.strength)?t.strength:1,damping:Number.isFinite(t.damping)?t.damping:1}}else if("number"==typeof t)r={count:t,strength:1,damping:1};else if("string"==typeof t){let a=PropertyParser.parseXYZFloat(e,!1,0,1,1,t);r={count:Math.abs(Math.round(a.x)),strength:a.y,damping:a.z}}return r}static parseWarp(e,t){let r;if("object"==typeof t){let e=Number.isFinite(t.amplitude)?t.amplitude:.5;r={amplitudeX:Number.isFinite(t.amplitudeX)?t.amplitudeX:e,amplitudeY:Number.isFinite(t.amplitudeY)?t.amplitudeY:e,amplitudeZ:Number.isFinite(t.amplitudeZ)?t.amplitudeZ:e,frequency:Number.isFinite(t.frequency)?t.frequency:.2}}else if("number"==typeof t)r={amplitudeX:t,amplitudeY:t,amplitudeZ:t,frequency:.2};else if("string"==typeof t){let a=t.split(/\s+/);if(1===a.length||2===a.length){let e=PropertyParser._parseFloatPart(a[0],.5);r={amplitudeX:e,amplitudeY:e,amplitudeZ:e,frequency:PropertyParser._parseFloatPart(a[1],.2)}}else{if(3!==a.length&&4!==a.length)throw{name:"SyntaxError",message:`'${e}' must have 1 to 4 values (amplitude [frequency] OR amplitudeX amplitudeY amplitudeZ [frequency])`};r={amplitudeX:PropertyParser._parseFloatPart(a[0],.5),amplitudeY:PropertyParser._parseFloatPart(a[1],.5),amplitudeZ:PropertyParser._parseFloatPart(a[2],.5),frequency:PropertyParser._parseFloatPart(a[3],.2)}}}return r}static parseShell(e,t){let r,a=!1;if(Array.isArray(t)){r=[];for(let e=0;e<t.length;e++){if(!t[e].colorId||!Number.isFinite(t[e].distance)){a=!0;break}r.push({colorId:t[e].colorId,distance:t[e].distance})}}else if("string"==typeof t&&t&&(r=[],"none"!==t)){let e=t.split(/\s+/);if(e.length<2||e.length%2!=0)a=!0;else for(let t=0;t<e.length/2;t++){let o=e[2*t+0],s=e[2*t+1];if(!/^[A-Z][a-z]*$/.test(o)||!/^([-+]?[0-9]*\.?[0-9]+)*$/.test(s)){a=!0;break}r.push({colorId:e[2*t],distance:e[2*t+1]})}}if(r&&0===r.length&&(r=void 0),a)throw{name:"SyntaxError",message:`Invalid value '${t}' for ${e}. Shell should be 'none' or one or more color ID's and distances, e.g. P 0.2 Q 0.4`};return r&&(r=r.sort((function(e,t){return e.distance-t.distance}))),r}static parseData(e,t){try{if(t){let e=[],r=t.split(/\s+/),a=null;for(let t=0;t<r.length;t++){let o=r[t];if(PropertyParser._stringIsNumber(o)){if(!a)break;a.values.push(PropertyParser._parseFloatPart(o))}else a={name:o,values:[]},e.push(a)}let o=0===e.length;for(let t=0;t<e.length;t++)o=o||0===e[t].values.length||e[t].values.length>=4;if(o)throw"error";return e}return}catch(r){throw{name:"SyntaxError",message:`Invalid value '${t}' for ''${e}'. Data should consist of one or more names, each followed by 1 to 4 float (default) values.`}}}static parseMapTransform(e,t){try{let e=(t||"-1 -1 0 0 0").split(/\s+/);if(2!==e.length&&4!==e.length&&5!==e.length)throw"error";return{uscale:PropertyParser._parseFloatPart(e[0],-1),vscale:PropertyParser._parseFloatPart(e[1],-1),uoffset:PropertyParser._parseFloatPart(e[2],0),voffset:PropertyParser._parseFloatPart(e[3],0),rotation:PropertyParser._parseFloatPart(e[4],0)}}catch(r){throw{name:"SyntaxError",message:`Invalid value '${t}' for '${e}'. '${e}' must have 2, 4 or 5 values.`}}}static parseColors(e,t){if(Array.isArray(t))return t;if(!t||0===t.length)return;let r=t;r=r.replace(/\s*\(\s*(\d+)\s*\)\s*/g,"($1)"),r=r.replace(/([A-Z][a-z]*)\s*(\(\d+\))?[:]\s*(#[a-fA-F0-9]*)\s*/g,"$1$2:$3 ").trim();let a=[];return r.split(/\s+/).forEach((function(t){let r=PropertyParser.parseColor(e,void 0,t.split(":")[1]);if(!r)throw{name:"SyntaxError",message:`Invalid '${e}' '${t}'.`};if(r.id=t.split(":")[0],r.exId=void 0,r.id.includes("(")&&(r.exId=Number(r.id.split("(")[1].replace(")","")),r.id=r.id.split("(")[0]),!/^[A-Z][a-z]*|_$/.test(r.id))throw{name:"SyntaxError",message:`Invalid color ID '${r.id}' for '${e}.`};a.push(r)})),a}}class PropertyWriter{static writeIntXYZ(e,t){return PropertyWriter.writeFloatXYZ(e,t)}static writeFloatXYZ(e,t){let r=null;return e&&(r=`${e.x}`,t&&e.y===e.x&&e.z===e.x||(r+=` ${e.y} ${e.z}`)),r}static writeVertexData(e){let t=null;if(e&&e.length>0){t="";for(let r=0;r<e.length;r++){t+=e[r].name+" ";for(let a=0;a<e[r].values.length;a++)t+=e[r].values[a]+" "}}return t.trim()}static writeAo(e){let t=null;return e&&(e.color||(e.color="#000"),Number.isFinite(e.maxDistance)||(e.maxDistance=1),Number.isFinite(e.intensity)||(e.intensity=1),Number.isFinite(e.angle)||(e.angle=70),t=`${e.color} ${e.maxDistance}`+(1!==e.intensity||70!==e.angle?" "+e.intensity:"")+(70!==e.angle?" "+e.angle:"")),t}static writeQuickAo(e){let t=null;return e&&(e.color||(e.color="#000"),Number.isFinite(e.intensity)||(e.intensity=1),t=`${e.color} ${1!==e.intensity?" "+e.intensity:""}`),t}static writeMapTransform(e){let t=null;return e&&(Number.isFinite(e.uscale)||(e.uscale=1),Number.isFinite(e.vscale)||(e.vscale=1),Number.isFinite(e.uoffset)||(e.uoffset=0),Number.isFinite(e.voffset)||(e.voffset=0),Number.isFinite(e.rotation)||(e.rotation=0),t=`${e.uscale} ${e.vscale}`+(0===e.uoffset&&0===e.voffset&&0===e.rotation?"":" "+e.uoffset+" "+e.voffset)+(0===e.rotation?"":" "+e.rotation)),t}static writeShell(e){let t=null;return e&&(t=`${0===e.length?"none":e.map((e=>e.colorId+" "+e.distance)).join(" ")}`),t}static writeDeform(e){let t=null;return e&&(Number.isFinite(e.count)||(e.count=1),Number.isFinite(e.strength)||(e.strength=1),Number.isFinite(e.damping)||(e.damping=1),t=`${e.count}${1!==e.strength||1!==e.damping?" "+e.strength:""}`+(1!==e.damping?" "+e.damping:"")),t}static writeWarp(e){let t=null;return e&&(!Number.isFinite(e.amplitudeX)&&Number.isFinite(e.amplitude)&&(e.amplitudeX=e.amplitude,e.amplitudeY=e.amplitude,e.amplitudeZ=e.amplitude),Number.isFinite(e.amplitudeX)&&Number.isFinite(e.amplitudeY)&&Number.isFinite(e.amplitudeZ)&&(t=e.amplitudeY===e.amplitudeX&&e.amplitudeZ===e.amplitudeX?`${e.amplitudeX} ${Number.isFinite(e.frequency)?e.frequency:.2}`:`${e.amplitudeX} ${e.amplitudeY} ${e.amplitudeZ} ${Number.isFinite(e.frequency)?e.frequency:.2}`)),t}static writeColors(e){return e.map((e=>`${e.id}${null==e.exId?"":"("+e.exId+")"}:${e._color}`)).join(" ")}}SVOX.TEXTUREDEFINITIONS={_texture:{doc:"Texture properties"},id:{doc:"The texture Id, which material maps reference.",format:"<string>",values:void 0,completion:"",dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"id")},borderOffset:{doc:"The borderoffset prevents texture bleeding. The default is 0.5 pixels but high resolutions textures may require a higher value.",format:"<borderoffset>",values:void 0,completion:"0.5",dontWrite:"0.5",write:void 0,parse:PropertyParser.parseFloat.bind(null,"borderoffset",.5)},size:{doc:"Used to prevent bleeding (reduce by setting size smaller).",format:"<float:size> | <x> <y>",values:void 0,completion:"512 512",dontWrite:void 0,write:e=>`${e.x} ${e.y}`,parse:PropertyParser.parseXYFloat.bind(null,"size",!0,void 0,void 0)},cube:{doc:"Wheter this is a cube texture.",format:void 0,values:["true","false"],completion:"false",dontWrite:"false",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"cube",void 0)},image:{doc:"The image in Base64 format. Load in the playground using 'Add Image'.",format:"data:image/<type>;base64,...",values:void 0,completion:"",dontWrite:void 0,write:void 0,parse:PropertyParser.parseString.bind(null,"image")}};class TextureReader{static read(e,t){let r=SVOX.TEXTUREDEFINITIONS;this._cleanupParameters(e,t);let a={};try{for(const t in r){let o=r[t],s=e[t];o.parse&&(s=o.parse(s)),void 0!==s&&(a[t]=s)}}catch(e){throw{name:e.name,message:`(${t}) ${e.message}`}}return this._validateSettings(a,t),a}static _cleanupParameters(e,t){let r=SVOX.TEXTUREDEFINITIONS;for(const a in e){let o=!1;for(const t in r)if(a.toLowerCase()===t.toLowerCase()){o=!0,a!==t&&(e[t]=e[a],delete e[a]);break}if(!o)throw{name:"SyntaxError",message:`(${t}) Unknown property '${a}' found in texture.`}}}static _validateSettings(e,t){if(!e.id)throw{name:"SyntaxError",message:`(${t}) Mandatory property 'id' not set in texture.`};if(!e.image)throw{name:"SyntaxError",message:`(${t}) Mandatory property 'image' not set in texture '${e.id}'.`}}}class TextureWriter{static write(e){let t=SVOX.TEXTUREDEFINITIONS,r=[];for(const a in e){let o=t[a];if(void 0!==o&&void 0!==e[a]){let t=o.write?o.write(e[a]):`${e[a]}`;t!==o.dontWrite&&r.push(`${a.toLowerCase()} = ${t}`)}}return"texture "+r.join(", ")}}SVOX.LIGHTDEFINITIONS={_light:{doc:"Light properties"},color:{doc:"The light color (default #FFF).",format:"<#RGB|#RRGGBB>",values:void 0,completion:"#F80",dontWrite:void 0,write:void 0,parse:PropertyParser.parseColor.bind(null,"color","#FFF")},intensity:{doc:"The intensity of the light.",format:"<float>",values:void 0,completion:"0.5",dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"intensity",1)},direction:{doc:"The direction from which the directional light shines.",format:"<x> <y> <z>",values:void 0,completion:"1 1 0",dontWrite:void 0,write:e=>`${e.x} ${e.y} ${e.z}`,parse:PropertyParser.parseXYZFloat.bind(null,"direction",!1,void 0,void 0,void 0)},atVoxel:{doc:"The color Id of the voxel(s) for which a light is created in its center. May result in many lights and slow rendering! ",format:"<ColorId>",values:void 0,completion:"V",dontWrite:void 0,write:e=>`${e}`,parse:PropertyParser.parseColorId.bind(null,"atvoxel")},position:{doc:"The position (in world coordinates!) at which the positional light is located. Distance & size in world units.",format:"<x> <y> <z>",values:void 0,completion:"2 2 0",dontWrite:void 0,write:e=>`${e.x} ${e.y} ${e.z}`,parse:PropertyParser.parseXYZFloat.bind(null,"position",!1,void 0,void 0,void 0)},distance:{doc:"For 'atvoxel' the distance in voxels that the light travels, but for 'position' these are world units",format:"<float>",values:void 0,completion:"10",dontWrite:void 0,write:void 0,parse:PropertyParser.parseFloat.bind(null,"distance",void 0)},size:{doc:"The size of the visible positional light sphere. For 'atvoxel' in voxels, for 'position' in world units.",format:"<float>",values:void 0,completion:"1",dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"size",0)},detail:{doc:"The detail of the visible positional light sphere.",format:void 0,values:["0","1","2","3"],completion:"2",dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"detail",void 0)},castShadow:{doc:"Defines whether this light casts baked shadows. Add castshadow = false to materials that have atvoxel lights.",format:void 0,values:["true","false"],completion:"true",dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"castShadow",void 0)},data:{doc:"Vertex data for use in shaders, so only for visible lights (detail <> 0). Names and values must match model data.",format:"[<attributename> <float1> ... <float4>]+ ",values:void 0,completion:"data 0.5 0.5",dontWrite:void 0,write:e=>PropertyWriter.writeVertexData(e),parse:PropertyParser.parseData.bind(null,"data")}};class LightReader{static read(e,t){let r=SVOX.LIGHTDEFINITIONS;this._cleanupParameters(e,t);let a={};try{for(const t in r){let o=r[t],s=e[t];o.parse&&(s=o.parse(s)),void 0!==s&&(a[t]=s)}}catch(e){throw{name:e.name,message:`(${t}) ${e.message}`}}return this._validateSettings(a,t),a}static _cleanupParameters(e,t){let r=SVOX.LIGHTDEFINITIONS;for(const a in e){let o=!1;for(const t in r)if(a.toLowerCase()===t.toLowerCase()){o=!0,a!==t&&(e[t]=e[a],delete e[a]);break}if(!o)throw{name:"SyntaxError",message:`(${t}) Unknown property '${a}' found in light.`}}}static _validateSettings(e,t){if(void 0!==e.detail&&(e.detail=Math.round(Math.min(3,Math.max(0,e.detail)))),e.direction&&e.position)throw{name:"SyntaxError",message:`(${t}) A light cannot have a 'direction' as well as a 'position'.`};if(e.direction&&e.atVoxel)throw{name:"SyntaxError",message:`(${t}) A light cannot have 'direction' as well as 'atvoxel'.`};if(e.position&&e.atVoxel)throw{name:"SyntaxError",message:`(${t}) A light cannot have a 'position' as well as 'atvoxel'.`};if(e.distance&&!e.position&&!e.atVoxel)throw{name:"SyntaxError",message:`'(${t}) Distance' is only supported for lights with a 'position' or 'atvoxel'.`};if(e.castShadow&&!e.direction&&!e.position&&!e.atVoxel)throw{name:"SyntaxError",message:`(${t}) Castshadow is only allowed in lights that have 'direction' or 'position'.`};if(!e.position&&!e.atVoxel&&(e.size||e.detail))throw{name:"SyntaxError",message:`(${t}) Only lights with a 'position' or 'atvoxel' can have size and detail.`};if(e.size>0&&void 0===e.detail&&(e.detail=1),void 0!==e.size&&0!==e.size||void 0===e.detail||SVOX.logWarning({name:"LightWarning",message:`(${t}) The light detail will be ignored because the size is not specified.`}),void 0===e.size&&void 0!==e.data)throw{name:"SyntaxError",message:`(${t}) Only visible lights, with a size property, can specify a data property.`};if(e.direction&&0===e.direction.x&&0===e.direction.y&&0===e.direction.z)throw{name:"SyntaxError",message:`(${t}) The direction of a directional light cannot be '0 0 0'.`}}}class LightWriter{static write(e){let t=SVOX.LIGHTDEFINITIONS,r=[];for(const a in e){let o=t[a];if(void 0!==o&&void 0!==e[a]){let t=o.write?o.write(e[a]):`${e[a]}`;t!==o.dontWrite&&r.push(`${a.toLowerCase()} = ${t}`)}}return"light "+r.join(", ")}}SVOX.GROUPDEFINITIONS={_group:{doc:"Group properties"},id:{doc:"The optional group Id, add materials to a group by adding group = <groupid> to the material.",format:"<string>",values:void 0,completion:"",dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"id",void 0)},clone:{doc:"Clone another group to reuse it, overwriting any of its properties, e.g. rotating or scaling the group and its children.",format:"<string>",values:void 0,completion:"",dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"clone",void 0)},prefab:{doc:"Prefab groups are clonable templates. Prefab properties are not overwritten when cloning. Prefabs cannot be nested.",format:void 0,values:["true","false"],completion:"true",dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"prefab",void 0)},group:{doc:"The group Id from a parent group, to which this group is attached, following it for rotation and translation.",format:"<string>",values:void 0,completion:"",dontWrite:"*",write:void 0,parse:PropertyParser.parseName.bind(null,"group","*")},recolor:{doc:"Recolor (some of) the colors for this group, or its sub groups, by specifying a new hexadecimal RGB value for them.",format:"[<colorid>:<#RGB|#RRGGBB>]+",values:void 0,completion:"V:#F80",dontWrite:void 0,write:e=>PropertyWriter.writeColors(e),parse:PropertyParser.parseColors.bind(null,"recolor")},scale:{doc:"The scale of the voxels for this group in voxels (0.5 = half the size of voxels in model).",format:"<x> [<y> <z>]",values:void 0,completion:"1 1 1",dontWrite:void 0,write:e=>PropertyWriter.writeFloatXYZ(e,!0),parse:PropertyParser.parseScale.bind(null,"scale",void 0)},origin:{doc:"The origin for the group.",format:"{ -x x +x -y y +y -z z +z }",values:void 0,completion:"-y",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPoint.bind(null,"origin",void 0)},resize:{doc:"Compensates for size change due to deform, warp or scatter.",format:void 0,values:["bounds","fit","fill"],completion:"fit",dontWrite:void 0,write:void 0,parse:PropertyParser.parseEnum.bind(null,"resize",["bounds","fit","fill"],void 0)},rotation:{doc:"The rotation of the group around its center over the three axes.",format:"<float:x> <float:y> <float:z>",values:void 0,completion:"0 45 0",dontWrite:void 0,write:e=>PropertyWriter.writeFloatXYZ(e,!1),parse:PropertyParser.parseXYZFloat.bind(null,"rotation",!1,void 0,void 0,void 0)},position:{doc:"The position of the group (in voxels coordinates from the parent group or model origin).",format:"<float:x> <float:y> <float:z>",values:void 0,completion:"0 0.5 0",dontWrite:void 0,write:e=>PropertyWriter.writeFloatXYZ(e,!1),parse:PropertyParser.parseXYZFloat.bind(null,"position",!1,void 0,void 0,void 0)},translation:{doc:"The translation of the group (in voxels coordinates from the original group position).",format:"<float:x> <float:y> <float:z>",values:void 0,completion:"0 0 0",dontWrite:void 0,write:e=>PropertyWriter.writeFloatXYZ(e,!1),parse:PropertyParser.parseXYZFloat.bind(null,"translation",!1,void 0,void 0,void 0)},_shape:{doc:"Shape properties"},shape:{doc:"Reshapes the group to fit in this shape. Is not applied to nested groups. Values cylinder-x, cylinder-y and cylinder-z will be deprecated in a future release!",format:void 0,values:["box","sphere","cylinderx","cylindery","cylinderz"],completion:"cylindery",dontWrite:void 0,write:void 0,parse:PropertyParser.parseEnum.bind(null,"shape",["box","sphere","cylinderx","cylindery","cylinderz"],void 0)},scaleYX:{doc:"Scale Y over X, i.e. scales the group in the Y direction depending on the X position. Is not applied to nested groups..  When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scaleyx")},scaleZX:{doc:"Scale Z over X, i.e. scales the group in the Z direction depending on the X position. Is not applied to nested groups.  When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalezx")},scaleXY:{doc:"Scale X over Y, i.e. scales the model in the X direction depending on the Y position. Is not applied to nested groups.  When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalexy")},scaleZY:{doc:"Scale Z over Y, i.e. scales the group in the Z direction depending on the Y position. Is not applied to nested groups.  When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalezy")},scaleXZ:{doc:"Scale X over Z, i.e. scales the group in the X direction depending on the Z position. Is not applied to nested groups.  When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalexz")},scaleYZ:{doc:"Scale Y over Z, i.e. scales the group in the Y direction depending on the Z position. Is not applied to nested groups.  When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scaleyz")},rotateX:{doc:"Rotate the group over the X axis, i.e. rotates the group depending on the X position. Is not applied to nested groups.",format:"<degrees0> <degrees1> ... <degreesN>",values:void 0,completion:"0 90 0",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"rotatex")},rotateY:{doc:"Rotate the group over the Y axis, i.e. rotates the group depending on the Y position. Is not applied to nested groups.",format:"<degrees0> <degrees1> ... <degreesN>",values:void 0,completion:"0 90 0",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"rotatey")},rotateZ:{doc:"Rotate the group over the Z axis, i.e. rotates the group depending on the Z position. Is not applied to nested groups.",format:"<degrees0> <degrees1> ... <degreesN>",values:void 0,completion:"0 90 0",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"rotatez")},translateYX:{doc:"Translate Y over X, i.e. translates the group in the Y direction depending on the X position. Is not applied to nested groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translateyx")},translateZX:{doc:"Translate Z over X, i.e. translates the group in the Z direction depending on the X position. Is not applied to nested groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatezx")},translateXY:{doc:"Translate X over Y, i.e. translates the group in the X direction depending on the Y position. Is not applied to nested groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatexy")},translateZY:{doc:"Translate Z over Y, i.e. translates the group in the Z direction depending on the Y position. Is not applied to nested groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatezy")},translateXZ:{doc:"Translate X over Z, i.e. translates the group in the X direction depending on the Z position. Is not applied to nested groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatexz")},translateYZ:{doc:"Translate Y over Z, i.e. translates the group in the Y direction depending on the Z position. Is not applied to nested groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translateyz")}};class GroupReader{static read(e,t){let r=SVOX.GROUPDEFINITIONS;this._cleanupParameters(e,t);let a={};try{for(const t in r){let o=r[t],s=e[t];o.parse&&(s=o.parse(s,o)),void 0!==s&&(a[t]=s)}}catch(e){throw{name:e.name,message:`(${t}) ${e.message}`}}return"*"===a.id&&"*"===a.group&&(a.group=void 0),this._validateSettings(a,t),a}static _cleanupParameters(e,t){let r=SVOX.GROUPDEFINITIONS;for(const a in e){let o=!1;for(const t in r)if(a.toLowerCase()===t.toLowerCase()){o=!0,a!==t&&(e[t]=e[a],delete e[a]);break}if(!o)throw{name:"SyntaxError",message:`(${t}) Unknown property '${a}' found in group.`}}e.shape&&["cylinder-x","cylinder-y","cylinder-z"].includes(e.shape)&&(SVOX.logWarning({name:"ModelWarning",message:`(${t}) '${e.shape}' is deprecated as value for 'shape'.`}),e.shape=e.shape.replace("-",""))}static _validateSettings(e,t){if(e.id||(e.id="UnnamedGroup"+SVOX.groupIdCount++),e.id===e.clone)throw{name:"ModelError",message:`(${t}) Group '${e.id}' cannot clone itself.`};if(e.translation&&e.position)throw{name:"ModelError",message:`(${t}) Group '${e.id}' uses translation, so it cannot also have a position.`}}}class GroupWriter{static write(e){let t=SVOX.GROUPDEFINITIONS,r=[];for(const a in e){if("id"===a&&e[a].startsWith("UnnamedGroup"))continue;let o=t[a];if(void 0!==o&&void 0!==e[a]){let t=o.write?o.write(e[a]):`${e[a]}`;t!==o.dontWrite&&r.push(`${a.toLowerCase()} = ${t}`)}}return"group "+r.join(", ")}}!function(){let e=!0,t=!0,r=!0,a=!0,o=!0,s=!0,i=!0,n=!0,l=!0;SVOX.MATERIALDEFINITIONS={_main:{doc:"Material properties"},type:{doc:"The material type.",format:void 0,values:["standard","phong","lambert","basic","toon","matcap","normal"],completion:"basic",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"standard",write:void 0,parse:PropertyParser.parseEnum.bind(null,"type",["basic","phong","lambert","standard","physical","toon","matcap","normal"],"standard")},name:{doc:"Internal material name (different names means extra materials / draw calls!).",format:"<string>",values:void 0,completion:"MyMaterial",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"name",void 0)},group:{doc:"The group Id from a group, to allow for rotation and translation of this separate group.",format:"<string>",values:void 0,completion:"",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"*",write:void 0,parse:PropertyParser.parseName.bind(null,"group","*")},lighting:{doc:"The lighting of the surface. Smooth, flat (triangles), quad (rectangles), both (smooth with clamped sides) or sides (smooth sides with hard edges).",format:void 0,values:["flat","quad","smooth","both","sides"],completion:"",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"flat",write:void 0,parse:PropertyParser.parseEnum.bind(null,"lighting",["flat","quad","smooth","both","sides"],"flat")},side:{doc:"Defines which side of faces will be rendered.",format:void 0,values:["front","back","double"],completion:"double",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"front",write:void 0,parse:PropertyParser.parseEnum.bind(null,"side",["front","back","double"],"front")},shadowSide:{doc:"Defines which side of faces cast shadows. Note, this is only applied to real lights, it is ignored for baked shadows!!",format:void 0,values:["front","back","double"],completion:"double",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseEnum.bind(null,"shadowSide",["front","back","double"],void 0)},wireframe:{doc:"Render the material as wireframe.",format:void 0,values:["true","false"],completion:"true",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"wireframe",void 0)},_surface:{doc:"Surface properties"},shininess:{doc:"A higher value (>1000) gives a sharper specular highlight.",format:"<shininess>",values:void 0,completion:"1000",base:e,phong:a,dontWrite:"30",write:void 0,parse:PropertyParser.parseFloat.bind(null,"shininess",30)},reflectivity:{doc:"Degree of reflectivity. Default is 0.5. For physical also changes refraction. Do not forget to set envmap for basic, lambert and phong materials!",format:"<reflectivity>",values:void 0,completion:"1",base:e,basic:t,lambert:r,phong:a,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseFloat.bind(null,"reflectivity",void 0)},combine:{doc:"How to combine the environment map, if any, with the diffuse color.",format:void 0,values:["add","multiply","mix"],completion:"add",base:e,basic:t,lambert:r,phong:a,dontWrite:"mix",write:void 0,parse:PropertyParser.parseEnum.bind(null,"combine",["multiply","mix","add"],"mix")},roughness:{doc:"How rough the material appears. 0.0 means a smooth mirror reflection.",format:"<float>",values:void 0,completion:.5,base:e,standard:o,physical:s,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"roughness",1)},metalness:{doc:"How much the material is like a metal. ",format:"<float>",values:void 0,completion:.5,base:e,standard:o,physical:s,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"metalness",0)},_maps:{doc:"Maps"},map:{doc:"Model texture. An alpha channel should be combined with transparent or alphatest.",format:"<textureid:RGB>",values:void 0,completion:"",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"map",void 0)},mapTransform:{doc:"Shift, scale or rotate textures.",format:"<width> <height> [<xoffset> <yoffset> [<rotation>]]",values:void 0,completion:"2 2 0.5 0.5 45",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"-1 -1",write:e=>PropertyWriter.writeMapTransform(e),parse:PropertyParser.parseMapTransform.bind(null,"maptransform")},normalMap:{doc:"The texture to create a normal map (e.g. visual bumps or ridges). ",format:"<textureid:Normal>",values:void 0,completion:"",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"normalmap",void 0)},normalScale:{doc:"How much the normal map affects the material. Allows for two values.",format:"<scale>|<xscale> <yscale>",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,values:void 0,completion:"1 1",dontWrite:"1 1",write:e=>`${e.x} ${e.y}`,parse:PropertyParser.parseXYFloat.bind(null,"normalscale",!0,1,1)},bumpMap:{doc:"The texture to create a bump map (e.g. visual bumps or ridges). ",format:"<textureid:Greyscale>",values:void 0,completion:"",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"bumpmap",void 0)},bumpScale:{doc:"How much the bump map affects the material.",format:"<float>",values:void 0,completion:"1",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"bumpscale",1)},envMap:{doc:"The environment map. You must set this for basic, lambert and phong materials as it is only automatically set for standard and physical materials!",format:"<textureid:RGB>",values:void 0,completion:"env",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"envmap",void 0)},envMapIntensity:{doc:"Scales the effect of the environment map by multiplying its color.",format:"<float>",values:void 0,completion:"1",base:e,standard:o,physical:s,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"envmapintensity",1)},roughnessMap:{doc:"The green channel alters the roughness of the material (requires roughness > 0).",format:"<textureid:Green-channel>",values:void 0,completion:"",base:e,standard:o,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"roughnessmap",void 0)},metalnessMap:{doc:"The blue channel is used, multiplied by metalness (i.e. use metalness = 1)",format:"<textureid:Blue-channel>",values:void 0,completion:"",base:e,standard:o,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"metalnessmap",void 0)},matcap:{doc:"The matcap map. See https://observablehq.com/@makio135/matcaps",format:"<textureid:RGB>",values:void 0,completion:"",base:e,matcap:n,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"matcap",void 0)},_transparency:{doc:"Transparency properties"},opacity:{doc:"A value of 0.0 indicates fully transparent, 1.0 is fully opaque.",format:"<float>",values:void 0,completion:"1",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"opacity",1)},transparent:{doc:"Defines whether this material is transparent. Mostly set automatically.",format:void 0,values:["true","false"],completion:!0,base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"transparent",void 0)},alphaTest:{doc:"The material will not see through if the opacity in the map is lower than this value. ",format:"<float>",values:void 0,completion:"0.5",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"alphatest",0)},alphaToCoverage:{doc:"Enable alpha to coverage to improve foliage transparency handling.",format:void 0,values:["true","false"],completion:!0,base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"alphatocoverage",void 0)},alphaMap:{doc:"Controls the opacity (0: transparent; 255: opaque).",format:"<textureid:Green-channel>",values:void 0,completion:"",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"alphamap",void 0)},_emissive:{doc:"Emissive properties"},emissive:{doc:"Emissive (light) color of the material.",format:"<#RGB|#RRGGBB>",values:void 0,completion:"#FFF",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,dontWrite:void 0,write:void 0,parse:PropertyParser.parseColor.bind(null,"emissive",void 0)},emissiveIntensity:{doc:"The intensity of the emissive light.",format:"<float>",values:void 0,completion:"1",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"emissiveintensity",1)},emissiveMap:{doc:"Emissive (glow) map (requires emissive color not black and emissiveintensity > 0)",format:"<textureid:RGB>",values:void 0,completion:"",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"emissivemap",void 0)},_specular:{doc:"Specular properties"},specular:{doc:"Specular color of the material. Default is #111 (very dark grey).",format:"<#RGB|#RRGGBB>",values:void 0,completion:"#888",base:e,phong:a,dontWrite:"#111",write:void 0,parse:PropertyParser.parseColor.bind(null,"specular","#111")},specularMap:{doc:"Specular map used by the material. Default is null.",format:"<textureid:Greyscale>",values:void 0,completion:"",base:e,basic:t,lambert:r,phong:a,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"specularmap",void 0)},specularColor:{doc:"Specular color of the material. Default is #FFF (white).",format:"<#RGB|#RRGGBB>",values:void 0,completion:"#FF0",base:e,physical:s,dontWrite:"#FFF",write:void 0,parse:PropertyParser.parseColor.bind(null,"specular","#FFF")},specularColorMap:{doc:"The RGB channels of this texture are multiplied against .specularColor.",format:"<textureid:RGB>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"specularcolormap",void 0)},specularIntensity:{doc:"A float that scales the amount of specular reflection for non-metals only.",format:"<float>",values:void 0,completion:"1",base:e,physical:s,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"specularintensity",1)},specularIntensityMap:{doc:"The alpha channel of this texture is multiplied against specularintensity.",format:"<textureid:Alpha-channel>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"specularintensitymap",void 0)},_refraction:{doc:"Refraction properties"},refractionRatio:{doc:"Index of refraction of air (~1) divided by the index of refraction of the material.",format:"<float>",values:void 0,completion:"0.9",base:e,basic:t,lambert:r,phong:a,dontWrite:void 0,write:void 0,parse:PropertyParser.parseFloat.bind(null,"refractionratio",void 0)},ior:{doc:"Index-of-refraction for non-metallic materials, from 1.0 to 2.333. Default is 1.5.",format:"<float>",values:void 0,completion:"1.5",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseFloat.bind(null,"ior",void 0)},thickness:{doc:"The thickness of the volume beneath the surface for refraction.",format:"<float>",values:void 0,completion:"1",base:e,physical:s,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"thickness",0)},thicknessMap:{doc:"G channel defines the thickness. Multiplied by thickness.",format:"<textureid:Green-channel>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"thicknessmap",void 0)},transmission:{doc:"Degree of transmission (or optical transparency), from 0.0 to 1.0.",format:"<float>",values:void 0,completion:"0.5",base:e,physical:s,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"transmission",1)},transmissionMap:{doc:"The red channel of this texture is multiplied against transmission.",format:"<textureid:Red-channel>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"transmissionmap",void 0)},attenuationColor:{doc:"The color that white light turns into due to absorption at the attenuation distance.",format:"<#RGB|#RRGGBB>",values:void 0,completion:"#F88",base:e,physical:s,dontWrite:"#FFF",write:void 0,parse:PropertyParser.parseColor.bind(null,"attenuationcolor","#FFF")},attenuationDistance:{doc:"The average distance (related to the thickness value) that light travels before interacting with a particle.",format:"<float>",values:void 0,completion:"1",base:e,physical:s,dontWrite:"Infinity",write:void 0,parse:PropertyParser.parseFloat.bind(null,"attenuationdistance",1/0)},_clearcoat:{doc:"Clearcoat properties"},clearcoat:{doc:"The intensity of the clear coat layer, from 0.0 to 1.0. ",format:"<float>",values:void 0,completion:"1",base:e,physical:s,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"clearcoat",0)},clearcoatMap:{doc:"The red channel of this texture is multiplied against clearcoat.",format:"<textureid:Red-channel>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"clearcoatmap",void 0)},clearcoatNormalMap:{doc:"Enables independent normals for the clear coat layer.",format:"<textureid:Normal>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"clearcoatnormalmap",void 0)},clearcoatNormalScale:{doc:"How much the clearcoatnormalmap affects the clear coat layer, from (0,0) to (1,1).",format:"<scale>|<xscale> <yscale>",values:void 0,completion:"1 1",base:e,physical:s,dontWrite:"1 1",write:e=>`${e.x} ${e.y}`,parse:PropertyParser.parseXYFloat.bind(null,"normalscale",!0,1,1)},clearcoatRoughness:{doc:"Roughness of the clear coat layer, from 0.0 to 1.0. Default is 0.0.",format:"<float>",values:void 0,completion:"0.5",base:e,physical:s,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"clearcoatroughness",0)},clearcoatRoughnessMap:{doc:"Requires clearcoatroughness > 1.",format:"<textureid:Green-channel>",values:void 0,completion:"",base:e,physical:s,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"clearcoatroughnessmap",void 0)},_displacement:{doc:"Displacement properties"},displacementMap:{doc:"White=high. Flat planes, a normalmap and simplify = false work best.",format:"<textureid:Greyscale>",values:void 0,completion:"",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseName.bind(null,"displacementmap",void 0)},displacementScale:{doc:"How much the displacement map affects the mesh.",format:"<float>",values:void 0,completion:"1",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"1",write:void 0,parse:PropertyParser.parseFloat.bind(null,"displacementscale",1)},displacementBias:{doc:"The offset of the displacement map's values on the mesh's vertices. ",format:"<float>",values:void 0,completion:"0",base:e,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"displacementbias",0)},_effects:{doc:"Effects properties"},blending:{doc:"Blending mode.",format:void 0,values:["no","normal","additive","subtractive","multiply"],completion:"additive",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"normal",write:void 0,parse:PropertyParser.parseEnum.bind(null,"blending",["no","normal","additive","subtractive","multiply"],"normal")},dithering:{doc:"Whether to apply dithering to remove the appearance of banding in slow gradients.",format:void 0,values:["true","false"],completion:"true",base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"false",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"dithering",!1)},fog:{doc:"Whether the material is affected by fog in a scene. Default is true.",format:void 0,values:["true","false"],completion:!0,base:e,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:"true",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"fog",!0)},lights:{doc:"Whether Smooth Voxel lights affect this surface.",format:void 0,values:["true","false"],completion:!1,basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:"true",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"lights",!0)},castShadow:{doc:"Defines whether this material casts baked shadows (and ao!). Add castshadow = false to materials that have atvoxel lights.",format:void 0,values:["true","false"],completion:"false",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"true",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"castShadow",!0)},receiveShadow:{doc:"Defines whether this material receives baked shadows (and ao!). By default materials receive baked shadows if a light with castshadow = true is present.",format:void 0,values:["true","false"],completion:"false",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:"true",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"receiveShadow",!0)},ao:{doc:"Calculate ambient occlusion.",format:"<#RGB|#RRGGBB> <maxdistance> [<intensity>] [<angle>]",values:void 0,completion:"#400 5 0.5",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:void 0,write:e=>PropertyWriter.writeAo(e),parse:PropertyParser.parseAo.bind(null,"ao")},quickAo:{doc:"Determines ambient occlusion by checking immediate neighboring voxels. Not suitable for deformed models. Overrules ao on the model.",format:"<#RGB|#RRGGBB> [<intensity>]",values:void 0,completion:"#400 0.5",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:void 0,write:e=>PropertyWriter.writeQuickAo(e),parse:PropertyParser.parseQuickAo.bind(null,"quickao")},shell:{doc:"Material shell or shells.",format:"[<colorId> <distance>]+",values:void 0,completion:"V 0.5 W 0.5",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>PropertyWriter.writeShell(e),parse:PropertyParser.parseShell.bind(null,"shell")},_deformation:{doc:"Deformation properties"},deform:{doc:"Deforms the surface by repeated averaging of vertices.",format:"<int:count> <float:strength> <float:damping>",values:void 0,completion:"3 1",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>PropertyWriter.writeDeform(e),parse:PropertyParser.parseDeform.bind(null,"deform")},warp:{doc:"Warps the voxels with an amplitude (distance in voxels) and frequency (in voxels). For ",format:"<float:ampl> [<float:freq>] OR <amplX> <amplY> <amplZ> [<freq>]",values:void 0,completion:"1 0.2",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>PropertyWriter.writeWarp(e),parse:PropertyParser.parseWarp.bind(null,"warp")},scatter:{doc:"Scatters the vertices. Distance is in voxels",format:"<float>",values:void 0,completion:"0.35",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:"0",write:void 0,parse:PropertyParser.parseFloat.bind(null,"scatter",0)},_planar:{doc:"Planar properties"},flatten:{doc:"Flattens as if a part is cut off. Note: uses material bounds, not model bounds.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"-y",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"flatten")},clamp:{doc:"Flattens with peripendicular sides. Note: uses material bounds, not model bounds.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"-y",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"clamp")},skip:{doc:"Faces are not created, do not influence other faces, do not have shells, etc. Note: uses material bounds, not model bounds.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"-y",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"skip")},hide:{doc:"Faces are created, influence other faces, have shells, etc. but do not add ambient occlusion, and are not created in the mesh. Note: uses material bounds, not model bounds.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"x y z",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"hide")},_shader:{doc:"Shader properties"},simplify:{doc:"By default faces are combined to reduce the model memory size, which may be unwanted for shaders.",format:void 0,values:["true","false"],completion:"false",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"simplify",void 0)},data:{doc:"Vertex data for use in shaders. Names and values must match model data.",format:"[<attributename> <float1> ... <float4>]+ ",values:void 0,completion:"data 0.5 0.5",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>PropertyWriter.writeVertexData(e),parse:PropertyParser.parseData.bind(null,"data")},_colors:{doc:"Color properties"},fade:{doc:"Whether colors in this material fade into each other",format:void 0,values:["true","false"],completion:"true",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,dontWrite:"false",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"fade",!1)},colors:{doc:"Colors for this material. Use fade=true to fade between them.\nMagica voxel palette index will be added when (re)loading .vox files in the playground.",format:"[<colorid>:<#RGB|#RRGGBB>]+|\n[<colorid>(<magicavoxindex>):<#RGB|#RRGGBB>]+",values:void 0,completion:"V:#F80",basic:t,lambert:r,phong:a,standard:o,physical:s,toon:i,matcap:n,normal:l,dontWrite:void 0,write:e=>PropertyWriter.writeColors(e),parse:PropertyParser.parseColors.bind(null,"colors")}},function(e){for(const t in e){let r=e[t],a=(r.basic?1:0)+(r.lambert?1:0)+(r.phong?1:0)+(r.standard?1:0)+(r.physical?1:0)+(r.toon?1:0)+(r.matcap?1:0)+(r.normal?1:0);8===a?r.allowedFor="Allowed for all materials":a<=4?(r.allowedFor="Allowed for ",r.basic&&(r.allowedFor+="basic, "),r.lambert&&(r.allowedFor+="lambert, "),r.phong&&(r.allowedFor+="phong, "),r.standard&&(r.allowedFor+="standard, "),r.physical&&(r.allowedFor+="physical, "),r.toon&&(r.allowedFor+="toon, "),r.matcap&&(r.allowedFor+="matcap, "),r.normal&&(r.allowedFor+="normal, "),r.allowedFor=r.allowedFor.slice(0,-2)):(r.allowedFor="NOT allowed for ",r.basic||(r.allowedFor+="basic, "),r.lambert||(r.allowedFor+="lambert, "),r.phong||(r.allowedFor+="phong, "),r.standard||(r.allowedFor+="standard, "),r.physical||(r.allowedFor+="physical, "),r.toon||(r.allowedFor+="toon, "),r.matcap||(r.allowedFor+="matcap, "),r.normal||(r.allowedFor+="normal, "),r.allowedFor=r.allowedFor.slice(0,-2)),r.allowedFor+="."}}(SVOX.MATERIALDEFINITIONS)}();class MaterialReader{static read(e,t,r){let a=SVOX.MATERIALDEFINITIONS,o={type:a.type.parse(e.type),base:{}};this._cleanupParameters(e,t,o.type);try{for(const t in a){if(a[t][o.type]){let r=a[t].parse(e[t]);void 0!==r&&(o[t]=r)}}}catch(e){throw{name:e.name,message:`(${t}) ${e.message}`}}this._validateSettings(o,t,r);for(const e in a){let t=a[e];t[o.type]&&t.base&&(o.base[e]=o[e])}return o.base.side=o.side===SVOX.DOUBLE?SVOX.DOUBLE:SVOX.FRONT,o}static _cleanupParameters(e,t,r){let a=SVOX.MATERIALDEFINITIONS,o=[];for(const s in e){let i=!1;for(const t in a)if(s.toLowerCase()===t.toLowerCase()){i=!0,a[t][r]?s!==t&&(e[t]=e[s],delete e[s]):o.push(s);break}if(!i)throw{name:"SyntaxError",message:`(${t}) Unknown property '${s}' found in material.`}}1===o.length&&SVOX.logWarning({name:"MaterialWarning",message:`(${t}) The property '${o[0]}' will be ignored for material type '${r}'`}),o.length>1&&SVOX.logWarning({name:"MaterialWarning",message:`(${t}) The properties '${o.join("', '").replace(/,([^,]*)$/," and $1")}' will be ignored for material type '${r}'`})}static _validateSettings(e,t,r){if(r&&(e.colors=[]),!e.colors||!r&&0===e.colors.length)throw{name:"SyntaxError",message:`(${t}) Mandatory property 'colors' not set in material '${e.type}'.`};if(e.ao&&e.quickAo)throw{name:"SyntaxError",message:`(${t}) The properties 'ao' and 'quickao' can not be used together in one material.`};e.type!==SVOX.MATSTANDARD&&e.type!==SVOX.MATPHYSICAL||void 0===e.metalness&&(e.metalness=e.metalnessmap?1:0),void 0===e.emissiveIntensity&&(e.emissive||e.emissiveMap)&&(e.emissiveIntensity=1),e.emissiveMap&&!e.emissive&&SVOX.logWarning({name:"MaterialWarning",message:`(${t}) Emissivemap only works in combination with emissive (e.g. emissive = #FFF) in material '${e.type}'.`}),void 0===e.transparent&&(e.transparent=e.transparent||e.opacity<1||e.alphaMap),!e.metalness&&e.metalnessMap&&SVOX.logWarning({name:"MaterialWarning",message:`(${t}) Metalnessmap only works in combination with a metalness > 0 in material '${e.type}'.`}),!e.roughness&&e.roughnessMap&&SVOX.logWarning({name:"MaterialWarning",message:`(${t}) Roughnessmap only works in combination with a roughness > 0 in material '${e.type}'.`}),e.clearcoatRoughnessMap&&!e.clearcoatRoughness&&SVOX.logWarning({name:"MaterialWarning",message:`(${t}) Clearcoatroughnessmap only works in combination with a clearcoatroughness > 0 in material '${e.type}'.`}),e.type!==SVOX.MATBASIC&&e.type!==SVOX.MATLAMBERT&&e.type!==SVOX.MATPHONG||!e.reflectivity||e.envMap||SVOX.logWarning({name:"MaterialWarning",message:`(${t}) Reflectivity only works in combination with envmap in material '${e.type}'.`})}}class MaterialWriter{static write(e){let t=SVOX.MATERIALDEFINITIONS,r=[];for(const a in e.settings){let o=t[a];if(void 0!==o&&void 0!==e.settings[a]){let t=o.write?o.write(e.settings[a]):`${e.settings[a]}`;t!==o.dontWrite&&r.push(`${a.toLowerCase()} = ${t}`)}}return"material "+r.join(", ")}}class VoxelReader{static createVoxels(e,t,r){let a=e.colors,o=null,s=[];if(r.matchAll)s=r.matchAll(/[0-9]+|[A-Z][a-z]*|-+|[()]/g);else{let e,t=RegExp("[0-9]+|[A-Z][a-z]*|-+|[()]","g");for(;null!==(e=t.exec(r));)s.push(e);s=s[Symbol.iterator]()}let i=this._unpackRle(s),n=e.settings.size,l=n.x*n.y*n.z,c=0;for(let e=0;e<i.length;e++)c+=i[e][1];if(c!==l)throw{name:"SyntaxError",message:`(${t}) The specified size is ${n.x} x ${n.y} x ${n.z} (= ${l} voxels) but the voxel matrix contains ${c} voxels.`};let d={minx:0,miny:0,minz:0,maxx:n.x-1,maxy:n.y-1,maxz:n.z-1,x:0,y:0,z:0};for(let r=0;r<i.length;r++){let s=null;"-"!==i[r][0]&&(s=a[i[r][0]],s||(SVOX.logWarning({name:"ModelWarning",message:`(${t}) Undefined color id '${i[r][0]}' found in the voxel matrix.`}),o||(o=e.materials.createMaterial(e,t,{type:SVOX.MATBASIC,lights:!1,quickao:{color:Color.fromHex("#000"),strength:.3}},!0)),s=o.addColor(Color.fromHex("#F0F")),s.id=i[r][0],a[s.id]=s)),this._setVoxels(e,s,i[r][1],d)}}static _unpackRle(e){let t=[],r=1,a=e.next();for(;!a.done;){let o=a.value[0];if(o[0]>="0"&&o[0]<="9")r=parseInt(o,10);else if("("===o){let a=this._unpackRle(e);for(let e=0;e<r;e++)Array.prototype.push.apply(t,a);r=1}else{if(")"===o)return t;o.length>1&&o[0]>="A"&&o[0]<="Z"&&o[1]===o[0]?(r>1?(t.push([o[0],r]),t.push([o[0],o.length-1])):t.push([o[0],o.length]),r=1):o.length>1&&"-"===o[0]&&"-"===o[1]?(r>1?(t.push(["-",r]),t.push(["-",o.length-1])):t.push(["-",o.length]),r=1):(t.push([o,r]),r=1)}a=e.next()}return t}static _setVoxels(e,t,r,a){for(;r-- >0;)t&&e.voxels.setVoxel(a.x,a.y,a.z,new Voxel(t)),a.x++,a.x>a.maxx&&(a.x=a.minx,a.y++),a.y>a.maxy&&(a.y=a.miny,a.z++)}}class VoxelWriter{static writeVoxels(e,t){let r=e.voxels,a=1;r.forEach((function(e){a=Math.max(e.color.id.length,a)}));let o=Math.min(a,3),s="-"+" ".repeat(o-1),i=" ".repeat(o),n="";for(let e=r.minZ;e<=r.maxZ;e++)for(let a=0;a<t;a++){for(let a=r.minY;a<=r.maxY;a++)for(let l=0;l<t;l++){for(let i=r.minX;i<=r.maxX;i++){let l=r.getVoxelForAnyGroup(i,a,e);for(let e=0;e<t;e++)if(l){n+=l.color.id;let e=l.color.id.length;for(;e++<o;)n+=" "}else n+=s}n+=i}n+="\r\n"}return n}static writeVoxelsRLE(e,t){let r,a=[],o=0;e.voxels.forEachInBoundary((function(e){let s=e?e.color:null;s===r?o++:(this._addRleChunk(a,r,o,t),r=s,o=1)}),this),this._addRleChunk(a,r,o,t);let s="";for(const e of a)s+=this._rleToString(e);return s}static _addRleChunk(e,t,r,a){if(0===r)return;let o=r>1?r.toString():"";o+=t?t.id:"-",e.push([o,1,o]);for(let t=Math.max(0,e.length-2*a);t<=e.length-2;t++){let r=e[t][0];for(let r=1;r<a&&!(t+2*r>e.length);r++){let a=!0;for(let o=0;o<=r-1&&(a=e[t+o][2]===e[t+o+r][2],a);o++);if(a){let a=e.splice(t,r);e.splice(t,r-1),e[t]=[a,2,null],e[t][2]=JSON.stringify(e[t]),t=e.length;break}}if(Array.isArray(r)&&e.length>t+r.length){let a=r,o=!0;for(let r=0;r<a.length&&(o=a[r][2]===e[t+1+r][2],o);r++);o&&(e.splice(t+1,a.length),e[t][1]++,e[t][2]=null,e[t][2]=JSON.stringify(e[t]),t=e.length)}}}static _rleToString(e){let t=1===e[1]?"":e[1].toString(),r=e[0];if(Array.isArray(r)){t+="(";for(let e of r)t+=this._rleToString(e);t+=")"}else t+=r;return t}}!function(){function e(e){for(const t in e){let r=e[t];r.name=t,r.format||(r.values?r.format=`{ ${r.values.join(" | ")} }`:r.format="")}}SVOX.MODELDEFINITIONS={_main:{doc:"Main properties"},size:{doc:"The size of the voxel matrix.",format:"<int:size> | <int:x> <int:y> <int:z>",values:void 0,completion:"10 10 10",dontWrite:void 0,write:e=>PropertyWriter.writeIntXYZ(e,!0),parse:PropertyParser.parseXYZInt.bind(null,"size",!0,void 0,void 0,void 0)},scale:{doc:"The scale of the voxels in world units (1 = 1 meter).",format:"<float:scale> | <float:x> <float:y> <float:z>",values:void 0,completion:"1 1 1",dontWrite:"1 1 1",write:e=>PropertyWriter.writeFloatXYZ(e,!0),parse:PropertyParser.parseScale.bind(null,"scale","1 1 1")},origin:{doc:"The origin for the model.",format:"{ -x x +x -y y +y -z z +z }",values:void 0,completion:"-y",dontWrite:"x y z",write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPoint.bind(null,"origin","x y z")},resize:{doc:"Compensates for size change due to deform, warp or scatter.",format:void 0,values:["bounds","fit","fill"],completion:"fit",dontWrite:void 0,write:void 0,parse:PropertyParser.parseEnum.bind(null,"resize",["bounds","fit","fill"],void 0)},rotation:{doc:"The rotation of the model over the three axes.",format:"<x> <y> <z>",values:void 0,completion:"0 45 0",dontWrite:"0 0 0",write:e=>PropertyWriter.writeFloatXYZ(e,!1),parse:PropertyParser.parseXYZFloat.bind(null,"rotation",!1,0,0,0)},position:{doc:"The position of the group (in world coordinates from the origin).",format:"<x> <y> <z>",values:void 0,completion:"0 1 0",dontWrite:"0 0 0",write:e=>PropertyWriter.writeFloatXYZ(e,!1),parse:PropertyParser.parseXYZFloat.bind(null,"position",!1,0,0,0)},wireframe:{doc:"Render the model as wireframe (excl. matcap materials).",format:void 0,values:["true","false"],completion:"true",dontWrite:void 0,write:void 0,parse:PropertyParser.parseBoolean.bind(null,"wireframe",void 0)},_shape:{doc:"Shape properties"},shape:{doc:"Reshapes the model to fit in this shape.  Is not applied to groups. Values cylinder-x, cylinder-y and cylinder-z will be deprecated in in a future release!",format:void 0,values:["box","sphere","cylinderx","cylindery","cylinderz"],completion:"cylindery",dontWrite:void 0,write:void 0,parse:PropertyParser.parseEnum.bind(null,"shape",["box","sphere","cylinderx","cylindery","cylinderz"],void 0)},scaleYX:{doc:"Scale Y over X, i.e. scales the group in the Y direction depending on the X position.  Is not applied to groups. When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scaleyx")},scaleZX:{doc:"Scale Z over X, i.e. scales the group in the Z direction depending on the X position.  Is not applied to groups. When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalezx")},scaleXY:{doc:"Scale X over Y, i.e. scales the model in the X direction depending on the Y position.  Is not applied to groups. When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalexy")},scaleZY:{doc:"Scale Z over Y, i.e. scales the group in the Z direction depending on the Y position.  Is not applied to groups. When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalezy")},scaleXZ:{doc:"Scale X over Z, i.e. scales the group in the X direction depending on the Z position.  Is not applied to groups. When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scalexz")},scaleYZ:{doc:"Scale Y over Z, i.e. scales the group in the Y direction depending on the Z position.  Is not applied to groups. When textures are distored use simplify = false.",format:"<scale0> <scale1> ... <scaleN>",values:void 0,completion:"1.5 0.5 1.5",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"scaleyz")},rotateX:{doc:"Rotate the group over the X axis, i.e. rotates the model depending on the X position. Is not applied to groups.",format:"<degrees0> <degrees1> ... <degreesN>",values:void 0,completion:"0 90 0",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"rotatex")},rotateY:{doc:"Rotate the group over the Y axis, i.e. rotates the model depending on the Y position. Is not applied to groups.",format:"<degrees0> <degrees1> ... <degreesN>",values:void 0,completion:"0 90 0",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"rotatey")},rotateZ:{doc:"Rotate the group over the Z axis, i.e. rotates the model depending on the Z position. Is not applied to groups.",format:"<degrees0> <degrees1> ... <degreesN>",values:void 0,completion:"0 90 0",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"rotatez")},translateYX:{doc:"Translate Y over X, i.e. translates the model in the Y direction depending on the X position. Is not applied to groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translateyx")},translateZX:{doc:"Translate Z over X, i.e. translates the model in the Z direction depending on the X position. Is not applied to groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatezx")},translateXY:{doc:"Translate X over Y, i.e. translates the model in the X direction depending on the Y position. Is not applied to groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatexy")},translateZY:{doc:"Translate Z over Y, i.e. translates the model in the Z direction depending on the Y position. Is not applied to groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatezy")},translateXZ:{doc:"Translate X over Z, i.e. translates the model in the X direction depending on the Z position. Is not applied to groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translatexz")},translateYZ:{doc:"Translate Y over Z, i.e. translates the model in the Y direction depending on the Z position. Is not applied to groups.",format:"<offset0> <offset1> ... <offsetN>",values:void 0,completion:"-1 1 -1",dontWrite:void 0,write:e=>e.join(" "),parse:PropertyParser.parseFloatArray.bind(null,"translateyz")},_planar:{doc:"Planar properties"},flatten:{doc:"Flattens as if a part is cut off.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"-y",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"flatten")},clamp:{doc:"Flattens with peripendicular sides.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"-y",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"clamp")},skip:{doc:"Faces are not created, do not influence other faces, do not have shells, etc.. Use skip unless hide is needed, as skip is faster.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"-y",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"skip")},hide:{doc:"Faces are created, influence other faces, have shells, etc. but do not add ambient occlusion, and are not created in the mesh.",format:"{ -x x +x -y y +y -z z +z | none }",values:void 0,completion:"x y z",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarPlanes.bind(null,"hide")},tile:{doc:"Don't warp or scatter these model edges to allow tiling",format:"{ x y z|-x +x -y +y -z +z | none }",values:void 0,completion:"x z",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarSides.bind(null,"tile")},_effects:{doc:"Effects properties"},ao:{doc:"Calculate ambient occlusion (not visible on normal materials). Max. distance in voxels.",format:"<#RGB|#RRGGBB> <maxdistance> [<intensity>] [<angle>]",values:void 0,completion:"#400 5 0.5",dontWrite:void 0,write:e=>PropertyWriter.writeAo(e),parse:PropertyParser.parseAo.bind(null,"ao")},quickAo:{doc:"Determines ambient occlusion by checking immediate neighboring voxels. Not suitable for deformed models.",format:"<#RGB|#RRGGBB> [<intensity>]",values:void 0,completion:"#400 0.5",dontWrite:void 0,write:e=>PropertyWriter.writeQuickAo(e),parse:PropertyParser.parseQuickAo.bind(null,"quickao")},aoSides:{doc:"The 'walls', 'floor' or 'ceiling' that occlude the model. Dependant on the bounds of the model (ignoring groups).",format:"{ -x +x -y +y -z +z | none }",values:void 0,completion:"-y",dontWrite:void 0,write:e=>`${Planar.toString(e)}`,parse:PropertyParser.parsePlanarSides.bind(null,"aosides")},aoSamples:{doc:"The number of samples (default 50) used to calculate ao. Higher looks better but genreates slower.",format:"<integer>",values:void 0,completion:"200",dontWrite:"50",write:void 0,parse:PropertyParser.parseFloat.bind(null,"aosamples",50)},shadowQuality:{doc:"When using castshadow = true on a lights, low shadow quality is less accurate and more blocky, but faster. Default is high.",format:void 0,values:["hight","low"],completion:"low",dontWrite:void 0,write:void 0,parse:PropertyParser.parseEnum.bind(null,"shadowquality",["high","low"],void 0)},shell:{doc:"Material shell or shells.",format:"[<colorId> <distance>]+",values:void 0,completion:"V 0.5 W 0.5",dontWrite:void 0,write:e=>PropertyWriter.writeShell(e),parse:PropertyParser.parseShell.bind(null,"shell")},_shader:{doc:"Shader properties"},simplify:{doc:"By default faces are combined to reduce the model memory size, which may be unwanted for shaders.",format:void 0,values:["true","false"],completion:"false",dontWrite:"true",write:void 0,parse:PropertyParser.parseBoolean.bind(null,"simplify",!0)},data:{doc:"Vertex data for use in shaders. Names and values in materials must match this definition.",format:"[<attributename> <float> <float> ...]+ ",values:void 0,completion:"data 0.5 0.5",dontWrite:void 0,write:e=>PropertyWriter.writeVertexData(e),parse:PropertyParser.parseData.bind(null,"data")}},e(SVOX.TEXTUREDEFINITIONS),e(SVOX.LIGHTDEFINITIONS),e(SVOX.GROUPDEFINITIONS),e(SVOX.MATERIALDEFINITIONS),e(SVOX.MODELDEFINITIONS)}();class ModelReader{static readFromString(e,t){let r=SVOX.MODELDEFINITIONS,a=this._convertToSinglePropertyLines(e),o=this._parse(a,t);this._cleanupParameters(o,t);let s={name:t};try{for(const e in r){let t=r[e],a=o[e];t.parse&&(a=t.parse(a)),void 0!==a&&(s[e]=a)}}catch(e){throw{name:e.name,message:`(${t}) ${e.message}`}}this._validateSettings(s,t);let i=new Model(s);if(this._createModelGroup(i),o.textures.forEach((function(e){i.textures.createTexture(e,t)}),this),SVOX.groupIdCount=1,o.groups.forEach((function(e){i.groups.createGroup(e,t)}),this),o.lights.some((e=>e.size))){i.materials.createMaterial(i,t,{type:SVOX.MATBASIC,lighting:SVOX.FLAT,colors:"_:#FFF"}).usedForLights=!0}if(o.lights.forEach((function(e){i.lights.createLight(e,t)}),this),o.materials.forEach((function(e){i.materials.createMaterial(i,t,e)}),this),i.colors={},i.materials.forEach((function(e){e.colors.forEach((function(e){i.colors[e.id]&&SVOX.logWarning({name:"ModelWarning",message:`(${t}) Duplicate color id '${e.id}' found.`}),i.colors[e.id]=e}))})),i.materials.forEach((function(e){this._compareVertexData(i.data,e.settings.data,"material")}),this),i.lights.forEach((function(e){this._compareVertexData(i.data,e.data,"light")}),this),this._resolveShellColors(i.shell,i),i.materials.forEach((function(e){this._resolveShellColors(e.shell,i)}),this),!o.voxels&&s.size&&(s.size.x>0||s.size.y>0||s.size.z>0))throw{name:"SyntaxError",message:`(${t}) No voxels found in model.`};return VoxelReader.createVoxels(i,t,o.voxels),i}static _convertToSinglePropertyLines(e){const t={emptyLines:new RegExp(/^[ ]*\r?\n/,"gm"),linecontinuation:new RegExp(/_\s*[\r\n]/gm),defines:new RegExp(/^\s*(define .*)/,"gm"),modelparts:new RegExp(/(;base64,.*$)\s*/.source+"|"+/\/\/.*$/.source+"|"+/\s*(texture|light|model|group(?!\s*=)|material|voxels)\s+/.source+"|"+/\s*([^=,\r\n]+=\s*data:image.*?base64,.*$)\s*/.source+"|"+/\s*([^=,\r\n]+=[^\r\n=;,\/]+)\s*/.source+"|"+/\s*(=[^\r\n=;,\/]+)\s*/.source+"|"+/\s*([A-Za-z \(\)\d -]+)\s*/.source,"gm")};e=(e=e.replaceAll(t.emptyLines,"")).replaceAll(t.linecontinuation," ");let r=Array.from(e.matchAll(t.defines),(e=>e[0].trim()));e=e.replaceAll(t.defines,""),r.reverse(),r.forEach((function(t){let r=(t=t.split(/\/\//,1)[0]).split(/\s+/);const a=r[1];r.shift(),r.shift();const o=r.join(" ");e=e.replaceAll(new RegExp(`\\b${a}\\b`,"gm"),o)}),this);let a=e.split(/\r\n|\n|\r/).map((e=>e.trim()));for(let e=0;e<a.length;e++){let t=a[e].indexOf("//");if(t>=0){let r=a[e].indexOf("data:image");(r>=0&&t<r||-1===r&&t>=0)&&(a[e]=a[e].substring(0,t).trim())}}return a=a.flatMap((e=>Array.from(e.matchAll(t.modelparts),(e=>e[0].trim())))).filter((e=>e)),a}static _parse(e,t){let r={lights:[],textures:[],groups:[],materials:[]},a=r,o=null,s=!1;if(e.filter((e=>e)).forEach((function(e){if(e.startsWith("//"));else if("texture"===e)a={},r.textures.push(a);else if("light"===e)a={},r.lights.push(a);else if("model"===e)a=r,s=!0;else if("group"===e)a={},r.groups.push(a);else if("material"===e)a={},r.materials.push(a);else if("voxels"===e)a=r,o="";else if(null!==o)o+=e.replace(/\s/g,"");else{let r=e.indexOf("=");if(-1===r)throw{name:"SyntaxError",message:`(${t}) Invalid definition '${e.length<=40?e:e.substring(0,40)+"..."}'.`};let o=e.substring(0,r).trim().toLowerCase(),s=e.substring(r+1).trim();if(""===s)throw{name:"SyntaxError",message:`(${t}) Invalid definition '${e.length<=40?e:e.substring(0,40)+"..."}'.`};a[o]=s}}),this),!s)throw{name:"SyntaxError",message:`(${t}) Missing mandatory 'model' keyword.`};return r.voxels=o,r}static _cleanupParameters(e,t){let r=SVOX.MODELDEFINITIONS;for(const a in e){let o=["textures","lights","groups","materials","voxels"].includes(a);for(const t in r)if(a.toLowerCase()===t.toLowerCase()){o=!0,a!==t&&(e[t]=e[a],delete e[a]);break}if(!o)throw{name:"SyntaxError",message:`(${t}) `+(""===a?`Syntax error before value '${e[a]}', are you missing a comma?`:`Unknown property '${a}' found in model.`)}}e.groups.forEach((function(r){if(r.clone&&r.group){let a=[r.id],o=e.groups.find((e=>e.id&&e.id===r.group));for(;o;){if(a.includes(o.id))throw a.unshift(o.id),{name:"ModelError",message:`(${t}) Group '${r.id}' cannot have itself as parent ( ${a.join("->")} ).`};if(a.unshift(o.id),o.id===r.clone)throw{name:"ModelError",message:`(${t}) Group '${r.id}' cannot clone its parent group '${r.clone}' ( ${a.join("->")} ).`};o=e.groups.find((e=>e.id&&e.id===o.group))}}}),this),e.groups.forEach((function(r){r.prefab&&this._checkForNestedPrefabs(t,e.groups,r.id,r.id)}),this),e.shape&&["cylinder-x","cylinder-y","cylinder-z"].includes(e.shape)&&(SVOX.logWarning({name:"ModelWarning",message:`(${t}) '${e.shape}' is deprecated as value for 'shape'.`}),e.shape=e.shape.replace("-",""))}static _checkForNestedPrefabs(e,t,r,a){t.forEach((function(o){if(r&&o.group===r){if("true"===o.prefab)throw{name:"ModelError",message:`(${e}) Prefab group '${o.id}' cannot be nested in prefab '${a}'`};this._checkForNestedPrefabs(e,t,o.id,a)}}),this)}static _validateSettings(e,t){if(!e.size)throw{name:"SyntaxError",message:`(${t}) Missing mandatory property 'size' in model.`};if(e.aoSamples=Math.max(8,Math.min(3e3,parseInt(e.aoSamples||50,10))),e.ao&&e.quickAo)throw{name:"SyntaxError",message:`(${t}) The properties 'ao' and 'quickao' can not be used together in the model settings. Use materials to override the model settings.`}}static _createModelGroup(e){e.groups.createGroup({id:"*",scale:e.scale,shape:e.shape,scaleYX:e.scaleYX,scaleZX:e.scaleZX,scaleXY:e.scaleXY,scaleZY:e.scaleZY,scaleXZ:e.scaleXZ,scaleYZ:e.scaleYZ,rotateX:e.rotateX,rotateY:e.rotateY,rotateZ:e.rotateZ,translateYX:e.translateYX,translateZX:e.translateZX,translateXY:e.translateXY,translateZY:e.translateZY,translateXZ:e.translateXZ,translateYZ:e.translateYZ,origin:e.origin,resize:e.resize,rotation:e.rotation,position:e.position})}static _resolveShellColors(e,t,r){e&&0!==e.length&&e.forEach((function(e){if(e.color=t.colors[e.colorId],!e.color)throw{name:"SyntaxError",message:`(${r}) shell color ID '${e.colorId}' not found in one of the materials.`}}),this)}static _compareVertexData(e,t,r){let a=!1;try{if((e||t)&&t){a=t&&!e;let r=[...t];t.length=0;for(let t=0;t<r.length;t++){let o=e.find((e=>e.name===r[t].name));a=a||!o||o.values.length!==r[t].values.length}for(let a=0;a<e.length;a++){let o=e[a],s=r.find((e=>e.name===o.name))||o;t.push(s)}}}catch(e){a=!0}if(a)throw{name:"SyntaxError",message:`The data property of the ${r} can only contain names defined in the model data, with identical number of values.`}}}class ModelWriter{static writeToString(e,t,r){r=Math.round(r||1);let a=function(e,t,a){a[t]=e*r};r>1&&(e.warp&&(e.warp.frequency/=r,e.warp.amplitude*=r,e.warp.amplitudeX*=r,e.warp.amplitudeY*=r,e.warp.amplitudeZ*=r),e.ao&&(e.ao.maxDistance*=r),e.groups.forEach((e=>{e.position&&(e.position.x*=r,e.position.y*=r,e.position.z*=r),e.translation&&(e.translation.x*=r,e.translation.y*=r,e.translation.z*=r),e.translateYX&&e.translateYX.forEach(a),e.translateZX&&e.translateZX.forEach(a),e.translateXY&&e.translateXY.forEach(a),e.translateZY&&e.translateZY.forEach(a),e.translateXZ&&e.translateXZ.forEach(a),e.translateYZ&&e.translateYZ.forEach(a)})),e.lights.forEach((e=>{e.position&&(e.position.x*=r,e.position.y*=r,e.position.z*=r),e.distance&&(e.distance*=r),e.size&&(e.size*=r),e.atVoxel&&(e.intensity=(e.intensity/(r*r)).toFixed(5))})),e.materials.forEach((e=>{if(e.warp&&(e.warp.frequency/=r,e.warp.amplitude*=r,e.warp.amplitudeX*=r,e.warp.amplitudeY*=r,e.warp.amplitudeZ*=r),e.ao&&e.ao.maxDistance&&(e.ao.maxDistance*=r),e.settings.mapTransform&&(-1!==e.settings.mapTransform.uscale&&(e.settings.mapTransform.uscale*=r),-1!==e.settings.mapTransform.vscale&&(e.settings.mapTransform.vscale*=r)),e.settings.deform&&(e.settings.deform.count+=e.settings.deform.count*(r*r)),e.shell)for(let t=0;t<e.shell.length;t++)e.shell[t].distance*=r}))),e.prepareForWrite();let o="",s=t?"":"\r\n";e.textures.length>0&&(e.textures.forEach((function(e){o+=TextureWriter.write(e)+"\r\n"})),o+=s),e.lights.length>0&&(e.lights.forEach((function(e){o+=LightWriter.write(e)+"\r\n"})),o+=s);let i=SVOX.MODELDEFINITIONS,n=[];for(const t in e.settings){let r=i[t];if(void 0!==r&&void 0!==e.settings[t]){let a=r.write?r.write(e.settings[t]):`${e.settings[t]}`;a!==r.dontWrite&&n.push(`${t.toLowerCase()} = ${a}`)}}if(1!==r){let t=n.findIndex((e=>"size ="===e.substring(0,6)));n[t]="size = "+SVOX.MODELDEFINITIONS.size.write({x:e.size.x*r,y:e.size.y*r,z:e.size.z*r});let a=n.findIndex((e=>"scale ="===e.substring(0,7)));-1===a&&(a=2,n.splice(a,0,"scale = 1 1 1")),n[a]="scale = "+SVOX.MODELDEFINITIONS.size.write({x:parseFloat((e.scale.x/r).toFixed(4)),y:parseFloat((e.scale.y/r).toFixed(4)),z:parseFloat((e.scale.z/r).toFixed(4))})}return o+=t?"model "+n.join(",")+"\r\n":"model\r\n"+n.join("\r\n")+"\r\n",o+=s,e.groups.length>1&&(e.groups.forEach((function(e){"*"!==e.id&&(o+=GroupWriter.write(e)+"\r\n")})),o+=s),e.materials.forEach((function(e){if(e.colorUsageCount>0&&!e.usedForLights){let r=MaterialWriter.write(e)+"\r\n";t||(r=r.replace(", colors =","\r\n  colors =")),o+=r}}),this),o+=s,t&&(o=o.replaceAll(" = ","=").replaceAll(", ",",")),o+=t&&1===r?"voxels "+VoxelWriter.writeVoxelsRLE(e,100):"voxels\r\n"+VoxelWriter.writeVoxels(e,r)+"\r\n",o}static _getShell(e){if(0===e.length)return"none";let t="";for(let r=0;r<e.length;r++)t+=`${e[r].colorId} ${e[r].distance} `;return t.trim()}}let hasFloat32Array="undefined"!=typeof Float32Array;class Matrix{constructor(){let e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];this.m=hasFloat32Array?new Float32Array(e):e}transformPoint(e){let t=this.m,r=t[12]*e.x+t[13]*e.y+t[14]*e.z+t[15],a=(t[0]*e.x+t[1]*e.y+t[2]*e.z+t[3])/r,o=(t[4]*e.x+t[5]*e.y+t[6]*e.z+t[7])/r,s=(t[8]*e.x+t[9]*e.y+t[10]*e.z+t[11])/r;e.x=a,e.y=o,e.z=s}transformVector(e){let t=this.m,r=t[0]*e.x+t[1]*e.y+t[2]*e.z,a=t[4]*e.x+t[5]*e.y+t[6]*e.z,o=t[8]*e.x+t[9]*e.y+t[10]*e.z;e.x=r,e.y=a,e.z=o}static identity(e){let t=(e=e||new Matrix).m;return t[0]=t[5]=t[10]=t[15]=1,t[1]=t[2]=t[3]=t[4]=t[6]=t[7]=t[8]=t[9]=t[11]=t[12]=t[13]=t[14]=0,e}static multiply(e,t,r){r=r||new Matrix;let a=e.m,o=t.m,s=r.m;return s[0]=a[0]*o[0]+a[1]*o[4]+a[2]*o[8]+a[3]*o[12],s[1]=a[0]*o[1]+a[1]*o[5]+a[2]*o[9]+a[3]*o[13],s[2]=a[0]*o[2]+a[1]*o[6]+a[2]*o[10]+a[3]*o[14],s[3]=a[0]*o[3]+a[1]*o[7]+a[2]*o[11]+a[3]*o[15],s[4]=a[4]*o[0]+a[5]*o[4]+a[6]*o[8]+a[7]*o[12],s[5]=a[4]*o[1]+a[5]*o[5]+a[6]*o[9]+a[7]*o[13],s[6]=a[4]*o[2]+a[5]*o[6]+a[6]*o[10]+a[7]*o[14],s[7]=a[4]*o[3]+a[5]*o[7]+a[6]*o[11]+a[7]*o[15],s[8]=a[8]*o[0]+a[9]*o[4]+a[10]*o[8]+a[11]*o[12],s[9]=a[8]*o[1]+a[9]*o[5]+a[10]*o[9]+a[11]*o[13],s[10]=a[8]*o[2]+a[9]*o[6]+a[10]*o[10]+a[11]*o[14],s[11]=a[8]*o[3]+a[9]*o[7]+a[10]*o[11]+a[11]*o[15],s[12]=a[12]*o[0]+a[13]*o[4]+a[14]*o[8]+a[15]*o[12],s[13]=a[12]*o[1]+a[13]*o[5]+a[14]*o[9]+a[15]*o[13],s[14]=a[12]*o[2]+a[13]*o[6]+a[14]*o[10]+a[15]*o[14],s[15]=a[12]*o[3]+a[13]*o[7]+a[14]*o[11]+a[15]*o[15],r}static transpose(e,t){t=t||new Matrix;let r=e.m,a=t.m;return a[0]=r[0],a[1]=r[4],a[2]=r[8],a[3]=r[12],a[4]=r[1],a[5]=r[5],a[6]=r[9],a[7]=r[13],a[8]=r[2],a[9]=r[6],a[10]=r[10],a[11]=r[14],a[12]=r[3],a[13]=r[7],a[14]=r[11],a[15]=r[15],t}static inverse(e,t){t=t||new Matrix;let r=e.m,a=t.m;a[0]=r[5]*r[10]*r[15]-r[5]*r[14]*r[11]-r[6]*r[9]*r[15]+r[6]*r[13]*r[11]+r[7]*r[9]*r[14]-r[7]*r[13]*r[10],a[1]=-r[1]*r[10]*r[15]+r[1]*r[14]*r[11]+r[2]*r[9]*r[15]-r[2]*r[13]*r[11]-r[3]*r[9]*r[14]+r[3]*r[13]*r[10],a[2]=r[1]*r[6]*r[15]-r[1]*r[14]*r[7]-r[2]*r[5]*r[15]+r[2]*r[13]*r[7]+r[3]*r[5]*r[14]-r[3]*r[13]*r[6],a[3]=-r[1]*r[6]*r[11]+r[1]*r[10]*r[7]+r[2]*r[5]*r[11]-r[2]*r[9]*r[7]-r[3]*r[5]*r[10]+r[3]*r[9]*r[6],a[4]=-r[4]*r[10]*r[15]+r[4]*r[14]*r[11]+r[6]*r[8]*r[15]-r[6]*r[12]*r[11]-r[7]*r[8]*r[14]+r[7]*r[12]*r[10],a[5]=r[0]*r[10]*r[15]-r[0]*r[14]*r[11]-r[2]*r[8]*r[15]+r[2]*r[12]*r[11]+r[3]*r[8]*r[14]-r[3]*r[12]*r[10],a[6]=-r[0]*r[6]*r[15]+r[0]*r[14]*r[7]+r[2]*r[4]*r[15]-r[2]*r[12]*r[7]-r[3]*r[4]*r[14]+r[3]*r[12]*r[6],a[7]=r[0]*r[6]*r[11]-r[0]*r[10]*r[7]-r[2]*r[4]*r[11]+r[2]*r[8]*r[7]+r[3]*r[4]*r[10]-r[3]*r[8]*r[6],a[8]=r[4]*r[9]*r[15]-r[4]*r[13]*r[11]-r[5]*r[8]*r[15]+r[5]*r[12]*r[11]+r[7]*r[8]*r[13]-r[7]*r[12]*r[9],a[9]=-r[0]*r[9]*r[15]+r[0]*r[13]*r[11]+r[1]*r[8]*r[15]-r[1]*r[12]*r[11]-r[3]*r[8]*r[13]+r[3]*r[12]*r[9],a[10]=r[0]*r[5]*r[15]-r[0]*r[13]*r[7]-r[1]*r[4]*r[15]+r[1]*r[12]*r[7]+r[3]*r[4]*r[13]-r[3]*r[12]*r[5],a[11]=-r[0]*r[5]*r[11]+r[0]*r[9]*r[7]+r[1]*r[4]*r[11]-r[1]*r[8]*r[7]-r[3]*r[4]*r[9]+r[3]*r[8]*r[5],a[12]=-r[4]*r[9]*r[14]+r[4]*r[13]*r[10]+r[5]*r[8]*r[14]-r[5]*r[12]*r[10]-r[6]*r[8]*r[13]+r[6]*r[12]*r[9],a[13]=r[0]*r[9]*r[14]-r[0]*r[13]*r[10]-r[1]*r[8]*r[14]+r[1]*r[12]*r[10]+r[2]*r[8]*r[13]-r[2]*r[12]*r[9],a[14]=-r[0]*r[5]*r[14]+r[0]*r[13]*r[6]+r[1]*r[4]*r[14]-r[1]*r[12]*r[6]-r[2]*r[4]*r[13]+r[2]*r[12]*r[5],a[15]=r[0]*r[5]*r[10]-r[0]*r[9]*r[6]-r[1]*r[4]*r[10]+r[1]*r[8]*r[6]+r[2]*r[4]*r[9]-r[2]*r[8]*r[5];let o=r[0]*a[0]+r[1]*a[4]+r[2]*a[8]+r[3]*a[12];for(let e=0;e<16;e++)a[e]/=o;return t}static scale(e,t,r,a){let o=(a=a||new Matrix).m;return o[0]=e,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=t,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=r,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,a}static translate(e,t,r,a){let o=(a=a||new Matrix).m;return o[0]=1,o[1]=0,o[2]=0,o[3]=e,o[4]=0,o[5]=1,o[6]=0,o[7]=t,o[8]=0,o[9]=0,o[10]=1,o[11]=r,o[12]=0,o[13]=0,o[14]=0,o[15]=1,a}static rotate(e,t,r,a,o){if(!e||!t&&!r&&!a)return Matrix.identity(o);let s=(o=o||new Matrix).m,i=Math.sqrt(t*t+r*r+a*a);e*=Math.PI/180,t/=i,r/=i,a/=i;let n=Math.cos(e),l=Math.sin(e),c=1-n;return s[0]=t*t*c+n,s[1]=t*r*c-a*l,s[2]=t*a*c+r*l,s[3]=0,s[4]=r*t*c+a*l,s[5]=r*r*c+n,s[6]=r*a*c-t*l,s[7]=0,s[8]=a*t*c-r*l,s[9]=a*r*c+t*l,s[10]=a*a*c+n,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,o}static lookAtORIGINAL(e,t,r,a,o,s,i,n,l,c){let d=(c=c||new Matrix).m,p=e-a,m=t-o,u=r-s,h=Math.sqrt(p*p+m*m+u*u);p/=h,m/=h,u/=h;let f=n*u-l*m,x=l*p-i*u,g=i*m-n*p;h=Math.sqrt(f*f+x*x+g*g),f/=h,x/=h,g/=h;let y=m*g-u*x,v=u*f-p*g,b=p*x-m*f;return h=Math.sqrt(y*y+v*v+b*b),y/=h,v/=h,b/=h,d[0]=f,d[1]=x,d[2]=g,d[3]=-(f*e+x*t+g*r),d[4]=y,d[5]=v,d[6]=b,d[7]=-(y*e+v*t+b*r),d[8]=p,d[9]=m,d[10]=u,d[11]=-(p*e+m*t+u*r),d[12]=0,d[13]=0,d[14]=0,d[15]=1,c}static lookAtTRYOUT(e,t,r,a){let o=(a=a||new Matrix).m,s=Math.sqrt(e*e+r*r);return o[0]=r/s,o[1]=0,o[2]=-e/s,o[3]=0,o[4]=e*t/s,o[5]=-s,o[6]=r*t/s,o[7]=0,o[8]=e,o[9]=t,o[10]=r,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,a}static lookAt(e,t,r,a){let o=(a=a||new Matrix).m,s=Math.sqrt(e*e+r*r),i=s?e/s:1,n=s?r/s:0;return o[0]=e,o[1]=-n,o[2]=-r*i,o[3]=0,o[4]=t,o[5]=0,o[6]=s,o[7]=0,o[8]=r,o[9]=i,o[10]=-r*n,o[11]=0,o[12]=0,o[13]=0,o[14]=0,o[15]=1,a}}SVOX.Noise=function(){let e=[];for(let t=0;t<256;t++)e[t]=Math.floor(256*Math.random()),e[t+256]=e[t];function t(e){return e*e*e*(e*(6*e-15)+10)}function r(e,t,r){return t+e*(r-t)}function a(e,t,r,a){let o=15&e,s=o<8?t:r,i=o<4?r:12==o||14==o?t:a;return(0==(1&o)?s:-s)+(0==(2&o)?i:-i)}return{noise:function(o,s,i){let n=Math.floor(o),l=Math.floor(s),c=Math.floor(i),d=255&n,p=255&l,m=255&c,u=(o-=n)-1,h=(s-=l)-1,f=(i-=c)-1,x=t(o),g=t(s),y=t(i),v=e[d]+p,b=e[v]+m,z=e[v+1]+m,w=e[d+1]+p,M=e[w]+m,S=e[w+1]+m;return r(y,r(g,r(x,a(e[b],o,s,i),a(e[M],u,s,i)),r(x,a(e[z],o,h,i),a(e[S],u,h,i))),r(g,r(x,a(e[b+1],o,s,f),a(e[M+1],u,s,i-1)),r(x,a(e[z+1],o,h,f),a(e[S+1],u,h,f))))}}};class GroupCloner{static cloneGroups(e){e.groups.forEach((function(t){if(t.prefab){let r=t.id+"_Prefab",a={id:r,group:t.group,prefab:!0};t.group=a.id,t.prefab=!1,e.groups.createGroup(a),e.groups.forEach((function(e){e.clone===t.id&&(e.clone=r,e.position||e.translation||(t.position&&(e.position={x:0,y:0,z:0}),t.translation&&(e.translation={x:0,y:0,z:0})))}),this)}}),this),e.groups.forEach((function(t){this._cloneGroup(e,t)}),this),e.groups.forEach((function(t){t.prefab&&this._propagatePrefab(e,t.id)}),this),e.groups.forEach((function(t){let r={};delete t.cloneProcessed;let a=t.clone?e.groups.getById(t.clone):null;a&&e.voxels.forEachInGroup(a.id,(function(a){let o=r[a.color.id];o||(t.recolor&&(o=t.recolor.find((e=>e.id===a.color.id)),o&&!o.material&&a.color.material.addColor(o)),o=o??a.color,r[a.color.id]=o),e.voxels.setVoxel(a.x,a.y,a.z,new Voxel(o,t))}),this)}),this),e.groups.forEach((function(t){t.prefab&&e.voxels.forEachInGroup(t.id,(function(r){e.voxels.clearVoxel(r.x,r.y,r.z,t.id)}),this)}),this),e.groups.removePrefabs()}static _cloneGroup(e,t){if(t.clone&&!t.cloneProcessed){t.cloneProcessed=!0;let r=e.groups.getById(t.clone);this._cloneProperties(t,r),this._cloneSubGroups(e,r.id,t)}}static _cloneProperties(e,t){for(const r in t)void 0!==e[r]||"id"===r||"prefab"===r||"clone"===r||"cloneProcessed"===r||r.endsWith("bounds")||(e[r]=t[r])}static _cloneSubGroups(e,t,r){e.groups.forEach((function(a){if(a.group===t){let t=r.id+"_"+a.id,o=a.clone??a.id,s={id:t,clone:o,group:r.id};this._cloneProperties(s,a),s.recolor=s.recolor??r.recolor,e.groups.createGroup(s),this._cloneSubGroups(e,o,s)}}),this)}static _propagatePrefab(e,t){e.groups.forEach((function(r){r.group===t&&(r.prefab=!0,this._propagatePrefab(e,r.id))}),this)}}class FaceCreator{static createAllFaces(e){e.voxels.forEach((function(t){let r=0;for(let a=0;a<SVOX._FACES.length;a++){let o=SVOX._FACES[a],s=SVOX._FACEOFFSETS[o],i=this._createFace(e,t,o,e.voxels.getVoxel(t.x+s.x,t.y+s.y,t.z+s.z,t.group.id));i&&(t.faces[o]=i,t.color.count++,r++)}t.visible=r>0}),this,!1)}static _createFace(e,t,r,a){let o=t?.material?.skip,s=a?.material?.skip;if(!t||!t.material||0===t.material.opacity)return null;if(a&&a.material){if(a.material===t.material)return null;if(t.material.side!==SVOX.BACK&&a.material.side===SVOX.BACK);else if(!o?.active&&s?.active&&(s?.x||s?.y||s?.z));else if(t.material.transparent&&a.material.wireframe);else{if(!a.material.transparent&&!a.material.wireframe)return null;if(t.material.transparent||t.material.wireframe)return null}}else;return this._isFacePlanar(e.voxels,t,r,t.material.skip,e.skip)?null:{vertices:[e.vertices.createVertex(t,r,0),e.vertices.createVertex(t,r,1),e.vertices.createVertex(t,r,2),e.vertices.createVertex(t,r,3)],ao:[0,0,0,0],uv:[null,null,null,null],flattened:this._isFacePlanar(e.voxels,t,r,t.material.flatten,e.flatten),clamped:this._isFacePlanar(e.voxels,t,r,t.material.clamp,e.clamp),hidden:this._isFacePlanar(e.voxels,t,r,t.material.hide,e.hide)}}static _isFacePlanar(e,t,r,a,o){let s=a,i=t.material.bounds;switch(s||(s=o,i=e.bounds),s||(r="not"),r){case"nx":return s.x||s.nx&&t.x===i.minX;case"px":return s.x||s.px&&t.x===i.maxX;case"ny":return s.y||s.ny&&t.y===i.minY;case"py":return s.y||s.py&&t.y===i.maxY;case"nz":return s.z||s.nz&&t.z===i.minZ;case"pz":return s.z||s.pz&&t.z===i.maxZ;default:return!1}}}class VertexLinker{static linkVertices(e){e.forEach((function(e){for(let t=0;t<SVOX._FACES.length;t++){let r=SVOX._FACES[t],a=e.faces[r];if(a){let e=a.vertices;if(a.clamped)for(let t=0;t<4;t++){let r=e[t];-1===r.links.indexOf(r)&&(r.links.push(r),r.nrOfClampedLinks++)}else for(let t=0;t<4;t++){let r=e[t],a=e[3===t?0:t+1];-1===r.links.indexOf(a)&&r.links.push(a),-1===a.links.indexOf(r)&&a.links.push(r)}}}}),this),this._fixClampedLinks(e)}static _fixClampedLinks(e){e.forEach((function(e){for(let t in e.faces){let r=e.faces[t];if(r.clamped)for(let e=0;e<4;e++){let t=r.vertices[e];t.fullyClamped=t.fullyClamped||t.nrOfClampedLinks===t.links.length,t.fullyClamped&&(t.links=[])}}}),this,!0),e.forEach((function(e){for(let t in e.faces){let r=e.faces[t];if(r.clamped)for(let e=0;e<4;e++){let t=r.vertices[e],a=r.vertices[(e+1)%4];t.fullyClamped&&-1===t.links.indexOf(a)&&t.links.push(a),a.fullyClamped&&-1===a.links.indexOf(t)&&a.links.push(t)}}}),this,!0)}static logLinks(e){e.forEach((function(e){for(let t in e.faces){let r=e.faces[t],a=`VOXEL (${e.x},${e.y},${e.z}):${t}\r\n`;for(let e=0;e<4;e++){let t=r.vertices[e];t.fullyClamped=t.fullyClamped||t.nrOfClampedLinks===t.links.length,a+=`    VERTEX (${t.x},${t.y},${t.z}):${t.fullyClampes?"fully":""} :`;for(let e=0;e<t.links.length;e++){let r=t.links[e];a+=`(${r.x},${r.y},${r.z}) `}a+="\r\n"}console.log(a)}}),this,!0)}}class ShapeModifier{static modify(e){let t=!1,r={};e.groups.forEach((function(e){let a={midX:(e.bounds.minX+e.bounds.maxX)/2,midY:(e.bounds.minY+e.bounds.maxY)/2,midZ:(e.bounds.minZ+e.bounds.maxZ)/2};switch(e.shape){case"sphere":a.circularDeform={xStrength:1,yStrength:1,zStrength:1},t=!0;break;case"cylinderx":a.circularDeform={xStrength:0,yStrength:1,zStrength:1},t=!0;break;case"cylindery":a.circularDeform={xStrength:1,yStrength:0,zStrength:1},t=!0;break;case"cylinderz":a.circularDeform={xStrength:1,yStrength:1,zStrength:0},t=!0}r[e.id]=a}),this),t&&this._circularDeform(e,r)}static _circularDeform(e,t){e.vertices.forEach((function(e){let r=t[e.group.id],a=r.circularDeform;if(a){let t=e.x-r.midX,o=e.y-r.midY,s=e.z-r.midZ,i=Math.max(Math.abs(t*a.xStrength),Math.abs(o*a.yStrength),Math.abs(s*a.zStrength)),n=Math.sqrt(t*t*a.xStrength+o*o*a.yStrength+s*s*a.zStrength);if(0===n)return;let l=i/n;e.x=t*(1-a.xStrength+a.xStrength*l)+r.midX,e.y=o*(1-a.yStrength+a.yStrength*l)+r.midY,e.z=s*(1-a.zStrength+a.zStrength*l)+r.midZ,e.ring=i}}),this),this._markEquidistantFaces(e)}static _markEquidistantFaces(e){e.voxels.forEach((function(e){for(let t in e.faces){let r=e.faces[t],a=r.vertices[0].ring;if(void 0!==a){r.equidistant=!0;for(let e=1;e<4;e++){if(r.vertices[e].ring!==a){r.equidistant=!1;break}}}}}),this,!0)}}class Deformer{static maximumDeformCount(e){let t=0;return e.materials.forEach((function(e){e.deform&&(t=Math.max(t,e.deform.count))})),t}static deform(e,t){for(let r=0;r<t;r++)e.vertices.forEach((function(e){if(e.deform&&e.deform.count>r){let t=e.links;if(t.length>0){let a=0,o=0,s=0;for(let e=0;e<t.length;e++)a+=t[e].x,o+=t[e].y,s+=t[e].z;let i=a/t.length-e.x,n=o/t.length-e.y,l=s/t.length-e.z,c=Math.pow(e.deform.damping,r)*e.deform.strength;0!==c&&(e.newX=e.x+i*c,e.newY=e.y+n*c,e.newZ=e.z+l*c,e.newSet=!0)}}}),this),this._repositionChangedVertices(e)}static warpAndScatter(e){let t=SVOX.Noise().noise,r=e.voxels,a=e.tile;e.vertices.forEach((function(e){if(a&&(a.nx&&e.x<r.minX+.1||a.px&&e.x>r.maxX-.1||a.ny&&e.y<r.minY+.1||a.py&&e.y>r.maxY-.1||a.nz&&e.z<r.minZ+.1||a.pz&&e.z>r.maxZ-.1))return;let o=e.warp?e.warp.amplitudeX:0,s=e.warp?e.warp.amplitudeY:0,i=e.warp?e.warp.amplitudeZ:0,n=e.warp?e.warp.frequency:0,l=e.scatter||0,c=0,d=0,p=0;(o||s||i)&&0!==n&&(c=t((e.x+.19)*n,e.y*n,e.z*n)*o,d=t((e.y+.17)*n,e.z*n,e.x*n)*s,p=t((e.z+.13)*n,e.x*n,e.y*n)*i),l&&(c+=(2*Math.random()-1)*l,d+=(2*Math.random()-1)*l,p+=(2*Math.random()-1)*l),0===c&&0==d&&0===p||(e.newX=e.x+c,e.newY=e.y+d,e.newZ=e.z+p,e.newSet=!0)}),this),this._repositionChangedVertices(e)}static _repositionChangedVertices(e){e.voxels.minX,e.voxels.maxX,e.voxels.minY,e.voxels.maxY,e.voxels.minZ,e.voxels.maxZ;e.vertices.forEach((function(e){e.newSet&&(e.x=e.flatten.x||e.clamp.x?e.x:e.newX,e.y=e.flatten.y||e.clamp.y?e.y:e.newY,e.z=e.flatten.z||e.clamp.z?e.z:e.newZ,e.newSet=!1)}),this)}}class SkewAndScaleAxisModifier{static modify(e){let t=!1,r=!1,a=!1,o={};e.groups.forEach((function(e){let s={bounds:e.vertexBounds,midX:(e.vertexBounds.minX+e.vertexBounds.maxX)/2,midY:(e.vertexBounds.minY+e.vertexBounds.maxY)/2,midZ:(e.vertexBounds.minZ+e.vertexBounds.maxZ)/2};s.scaleYX=e.scaleYX,t=t||s.scaleYX,s.scaleZX=e.scaleZX,t=t||s.scaleZX,s.scaleXY=e.scaleXY,t=t||s.scaleXY,s.scaleZY=e.scaleZY,t=t||s.scaleZY,s.scaleXZ=e.scaleXZ,t=t||s.scaleXZ,s.scaleYZ=e.scaleYZ,t=t||s.scaleYZ,s.rotateX=e.rotateX,r=r||s.rotateX,s.rotateY=e.rotateY,r=r||s.rotateY,s.rotateZ=e.rotateZ,r=r||s.rotateZ,s.translateYX=e.translateYX,a=a||s.translateYX,s.translateZX=e.translateZX,a=a||s.translateZX,s.translateXY=e.translateXY,a=a||s.translateXY,s.translateZY=e.translateZY,a=a||s.translateZY,s.translateXZ=e.translateXZ,a=a||s.translateXZ,s.translateYZ=e.translateYZ,a=a||s.translateYZ,o[e.id]=s}),this),(t||r||a)&&e.vertices.forEach((function(e){e.newX=e.x,e.newY=e.y,e.newZ=e.z}),this),t&&this._scale(e,o),r&&this._rotate(e,o),a&&this._translate(e,o)}static _scale(e,t){e.vertices.forEach((function(e){let r=t[e.group.id],a=e.newX,o=e.newY,s=e.newZ;if(r.scaleYX){let t=(a-r.bounds.minX)/(r.bounds.sizeX??1);e.y=(e.y-r.midY)*this._interpolate(r.scaleYX,t)+r.midY}if(r.scaleZX){let t=(a-r.bounds.minX)/(r.bounds.sizeX??1);e.z=(e.z-r.midZ)*this._interpolate(r.scaleZX,t)+r.midZ}if(r.scaleXY){let t=(o-r.bounds.minY)/(r.bounds.sizeY??1);e.x=(e.x-r.midX)*this._interpolate(r.scaleXY,t)+r.midX}if(r.scaleZY){let t=(o-r.bounds.minY)/(r.bounds.sizeY??1);e.z=(e.z-r.midZ)*this._interpolate(r.scaleZY,t)+r.midZ}if(r.scaleXZ){let t=(s-r.bounds.minZ)/(r.bounds.sizeZ??1);e.x=(e.x-r.midX)*this._interpolate(r.scaleXZ,t)+r.midX}if(r.scaleYZ){let t=(s-r.bounds.minZ)/(r.bounds.sizeZ??1);e.y=(e.y-r.midY)*this._interpolate(r.scaleYZ,t)+r.midY}}),this)}static _rotate(e,t){e.vertices.forEach((function(e){let r=t[e.group.id],a=e.newX,o=e.newY,s=e.newZ;if(r.rotateX){let t=(a-r.bounds.minX)/(r.bounds.sizeX??1),o=this._interpolate(r.rotateX,t);this._rotateVertex(e,"y","z",r.midY,r.midZ,o)}if(r.rotateY){let t=(o-r.bounds.minY)/(r.bounds.sizeY??1),a=this._interpolate(r.rotateY,t);this._rotateVertex(e,"x","z",r.midX,r.midZ,-a)}if(r.rotateZ){let t=(s-r.bounds.minZ)/(r.bounds.sizeZ??1),a=this._interpolate(r.rotateZ,t);this._rotateVertex(e,"x","y",r.midX,r.midY,a)}}),this)}static _translate(e,t){e.vertices.forEach((function(e){let r=t[e.group.id],a=e.newX,o=e.newY,s=e.newZ;if(r.translateYX){let t=(a-r.bounds.minX)/(r.bounds.sizeX??1);e.y+=this._interpolate(r.translateYX,t)}if(r.translateZX){let t=(a-r.bounds.minX)/(r.bounds.sizeX??1);e.z+=this._interpolate(r.translateZX,t)}if(r.translateXY){let t=(o-r.bounds.minY)/(r.bounds.sizeY??1);e.x+=this._interpolate(r.translateXY,t)}if(r.translateZY){let t=(o-r.bounds.minY)/(r.bounds.sizeY??1);e.z+=this._interpolate(r.translateZY,t)}if(r.translateXZ){let t=(s-r.bounds.minZ)/(r.bounds.sizeZ??1);e.x+=this._interpolate(r.translateXZ,t)}if(r.translateYZ){let t=(s-r.bounds.minZ)/(r.bounds.sizeZ??1);e.y+=this._interpolate(r.translateYZ,t)}}),this)}static _rotateVertex(e,t,r,a,o,s){let i=Math.PI*s/180,n=Math.cos(i),l=Math.sin(i),c=e[t]-a,d=e[r]-o,p=c*n-d*l,m=c*l+d*n;e[t]=p+a,e[r]=m+o}static _interpolate(e,t){if(e.length<2)throw new Error("Interpolation arrray must contain at least 2 values.");if(t<0||t>1)throw new Error("Interpolation value d must be a float between 0 and 1.");let r=(e.length-1)*t,a=Math.floor(r),o=e[a],s=r-a;return 0===s?o:o+s*(e[Math.ceil(r)]-o)}}class VertexTransformer{static transformVertices(e){e.groups.forEach((function(t){let r=this.getGroupHierarchy(t,e.groups),a=0;for(let e=r.length-1;e>=0&&!r[e].translation;e--)a=e;let o=[],s=t.bounds.getCenter();o.push({type:"translate",x:-s.x,y:-s.y,z:-s.z});for(let s=0;s<r.length;s++){let i=r[s],n={scale:{x:1,y:1,z:1}};if("*"!==i.id&&(n=e.groups.getById(i.group)),i.id===t.id&&o.push({type:"scale",x:i.vertexRescale.x,y:i.vertexRescale.y,z:i.vertexRescale.z}),i.scale&&o.push({type:"scale",x:i.scale.x,y:i.scale.y,z:i.scale.z}),0===s&&o.push({type:"translate",x:i.originOffset.x*(i?.scale?.x??1),y:i.originOffset.y*(i?.scale?.y??1),z:i.originOffset.z*(i?.scale?.z??1)}),i.rotation&&o.push({type:"rotate",x:i.rotation.x,y:i.rotation.y,z:i.rotation.z}),i.position?o.push({type:"translate",x:i.position.x,y:i.position.y,z:i.position.z}):i.translation&&o.push({type:"translate",x:i.translation.x,y:i.translation.y,z:i.translation.z}),0===s&&t.translation){let e=t.bounds.getCenter(),s=r[a].bounds.getCenter(),i=r[a].originOffset;o.push({type:"translate",x:e.x-s.x+i.x,y:e.y-s.y+i.y,z:e.z-s.z+i.z})}}this.logTransformations(t.id,o),t.vertexTransform=this.getTransformationMatrix(o),t.normalTransform=Matrix.transpose(t.vertexTransform),t.normalTransform=Matrix.inverse(t.normalTransform)}),this),e.vertices.forEach((function(e){e.group.vertexTransform.transformPoint(e)}),this),e.voxels.forEach((function(t){const r=t.group.normalTransform;for(let a in t.faces){let o=t.faces[a];if(o)for(let t=0;t<o.normals.length;t++)o.flatNormals[t].transformed||(r.transformVector(o.flatNormals[t]),e._normalize(o.flatNormals[t]),o.flatNormals[t].transformed=!0),o.smoothNormals[t].transformed||(r.transformVector(o.smoothNormals[t]),e._normalize(o.smoothNormals[t]),o.smoothNormals[t].transformed=!0),o.bothNormals[t].transformed||(r.transformVector(o.bothNormals[t]),e._normalize(o.bothNormals[t]),o.bothNormals[t].transformed=!0),o.sideNormals[t].transformed||(r.transformVector(o.sideNormals[t]),e._normalize(o.sideNormals[t]),o.sideNormals[t].transformed=!0)}}),this,!0)}static getGroupHierarchy(e,t,r=[]){if(r.push(e),e.group){let a=t.getById(e.group);if(r.some((e=>e.id===a.id))){throw{name:"ModelError",message:`The groups ${r.reduce((function(e,t){return e+t.id+" > "}),"")+a.id} are circularly nested.`}}this.getGroupHierarchy(a,t,r)}return r}static logTransformations(e,t){for(let e=0;e<t.length;e++){t[e]}}static getTransformationMatrix(e){let t=new Matrix;for(let r=e.length-1;r>=0;r--){let a=e[r];switch(a.type){case"translate":t=Matrix.multiply(t,Matrix.translate(a.x,a.y,a.z));break;case"rotate":t=Matrix.multiply(t,Matrix.rotate(a.z,0,0,1)),t=Matrix.multiply(t,Matrix.rotate(a.y,0,1,0)),t=Matrix.multiply(t,Matrix.rotate(a.x,1,0,0));break;case"scale":t=Matrix.multiply(t,Matrix.scale(a.x,a.y,a.z))}}return t}}class NormalsCalculator{static calculateNormals(e){let t=e.tile,r=e.voxels;r.forEach((function(a){for(let o in a.faces){let s=a.faces[o];if(s.skipped)continue;s.smooth=!(a.material.lighting!==SVOX.SMOOTH&&a.material.lighting!==SVOX.BOTH||!0!==s.equidistant&&(void 0!==s.equidistant||s.flattened||s.clamped));let i={x:(s.vertices[0].x+s.vertices[1].x+s.vertices[2].x+s.vertices[3].x)/4,y:(s.vertices[0].y+s.vertices[1].y+s.vertices[2].y+s.vertices[3].y)/4,z:(s.vertices[0].z+s.vertices[1].z+s.vertices[2].z+s.vertices[3].z)/4};s.flatNormals=[null,null,null,null],s.smoothNormals=[null,null,null,null],s.bothNormals=[null,null,null,null],s.sideNormals=[null,null,null,null];for(let n=0;n<4;n++){let l=s.vertices[n],c=s.vertices[(n+3)%4];l.smoothNormal=l.smoothNormal||{x:0,y:0,z:0},l.bothNormal=l.bothNormal||{x:0,y:0,z:0},l.sideNormals||(l.sideNormals={}),l.sideNormals[o]||(l.sideNormals[o]={x:0,y:0,z:0});let d=c.x-l.x,p=c.y-l.y,m=c.z-l.z,u=i.x-l.x,h=i.y-l.y,f=i.z-l.z,x={x:p*f-m*h,y:m*u-d*f,z:d*h-p*u},g=a.material.clamp??e.clamp,y=a.material.flatten??e.flatten,v=(t&&t.nx||g&&(g.x||g.nx))&&l.x<r.minX+1e-4,b=(t&&t.px||g&&(g.x||g.px))&&l.x>r.maxX-1e-4,z=(t&&t.ny||g&&(g.y||g.ny))&&l.y<r.minY+1e-4,w=(t&&t.py||g&&(g.y||g.py))&&l.y>r.maxY-1e-4,M=(t&&t.nz||g&&(g.z||g.nz))&&l.z<r.minZ+1e-4,S=(t&&t.pz||g&&(g.z||g.pz))&&l.z>r.maxZ-1e-4;!v&&!b||"ny"!==o&&"py"!==o&&"nz"!==o&&"pz"!==o||(x.x=0),!z&&!w||"nx"!==o&&"px"!==o&&"nz"!==o&&"pz"!==o||(x.y=0),!M&&!S||"nx"!==o&&"px"!==o&&"ny"!==o&&"py"!==o||(x.z=0),a.material.type===SVOX.BOTH&&("nx"===o&&(v||g&&(g.x||g.nx)||y&&(y.x||y.nx))&&(x.x=-1,x.y=0,x.z=0),"px"===o&&(b||g&&(g.x||g.px)||y&&(y.x||y.px))&&(x.x=1,x.y=0,x.z=0),"ny"===o&&(z||g&&(g.y||g.ny)||y&&(y.y||y.ny))&&(x.x=0,x.y=-1,x.z=0),"py"===o&&(w||g&&(g.y||g.py)||y&&(y.y||y.py))&&(x.x=0,x.y=1,x.z=0),"nz"===o&&(M||g&&(g.z||g.nz)||y&&(y.z||y.nz))&&(x.x=0,x.y=0,x.z=-1),"pz"===o&&(S||g&&(g.z||g.pz)||y&&(y.z||y.pz))&&(x.x=0,x.y=0,x.z=1)),Math.abs(x.x)<1e-4&&(x.x=0),Math.abs(x.y)<1e-4&&(x.y=0),Math.abs(x.z)<1e-4&&(x.z=0),e._normalize(x),s.flatNormals[n]=x,l.smoothNormal.x+=x.x,l.smoothNormal.y+=x.y,l.smoothNormal.z+=x.z,s.smooth&&(l.bothNormal.x+=x.x,l.bothNormal.y+=x.y,l.bothNormal.z+=x.z),l.sideNormals[o].x+=x.x,l.sideNormals[o].y+=x.y,l.sideNormals[o].z+=x.z}}}),this,!0),e.vertices.forEach((function(t){if(e._normalize(t.smoothNormal),e._normalize(t.bothNormal),t.sideNormals)for(let r in t.sideNormals)e._normalize(t.sideNormals[r])}),this);let a=0;e.voxels.forEach((function(t){for(let r in t.faces){let o=t.faces[r];if(!o.skipped){switch(o.smoothNormals[0]=o.vertices[0].smoothNormal,o.smoothNormals[1]=o.vertices[1].smoothNormal,o.smoothNormals[2]=o.vertices[2].smoothNormal,o.smoothNormals[3]=o.vertices[3].smoothNormal,o.bothNormals[0]=!o.smooth||e._isZero(o.vertices[0].bothNormal)?o.flatNormals[0]:o.vertices[0].bothNormal,o.bothNormals[1]=!o.smooth||e._isZero(o.vertices[1].bothNormal)?o.flatNormals[1]:o.vertices[1].bothNormal,o.bothNormals[2]=!o.smooth||e._isZero(o.vertices[2].bothNormal)?o.flatNormals[2]:o.vertices[2].bothNormal,o.bothNormals[3]=!o.smooth||e._isZero(o.vertices[3].bothNormal)?o.flatNormals[3]:o.vertices[3].bothNormal,o.sideNormals[0]=o.vertices[0].sideNormals?.[r],o.sideNormals[1]=o.vertices[1].sideNormals?.[r],o.sideNormals[2]=o.vertices[2].sideNormals?.[r],o.sideNormals[3]=o.vertices[3].sideNormals?.[r],t.material.lighting){case SVOX.SMOOTH:o.normals=o.smoothNormals;break;case SVOX.BOTH:o.normals=o.bothNormals;break;case SVOX.SIDES:o.normals=o.sideNormals;break;default:o.normals=o.flatNormals}for(let e=0;e<4;e++){let t=o.normals[e];if(0===t.x&&0===t.y&&0===t.z){let r=o.normals[(e+3)%4];t.x=r.x,t.y=r.y,t.z=r.z}}if((t.material.lighting===SVOX.SMOOTH||t.material.lighting===SVOX.BOTH)&&this._isNonManifold(o))for(let e=0;e<4;e++)o.vertices[e].nonManifold&&(o.normals[e]=o.flatNormals[e],a++)}}}),this,!0),a>0&&SVOX.logInfo({name:"ModelHint",message:`Non manifold vertices detected. Smooth Voxels replaced ${a} bad smooth normals with flat normals. When possible try to avoid non manifold models with smooth lighting for better results.`},e.name)}static _isNonManifold(e){let t=!1;for(let r=0;r<4;r++){let a=e.vertices[r],o=0;!0===a.faces.px&&!0===a.faces.nx&&o++,!0===a.faces.py&&!0===a.faces.ny&&o++,!0===a.faces.pz&&!0===a.faces.nz&&o++,a.nonManifold=o>=2,t=t||a.nonManifold}return t}}class Octree{constructor(e){const t=.1*Math.min(e.scale.x,e.scale.y,e.scale.z);let r=this._getAllFaceTriangles(e);this.octree=this._trianglesToOctree(r),e.aoSides&&(this.octree=this._aoSidesToOctree(e,this.octree,t))}_getAllFaceTriangles(e){let t=[];return e.voxels.forEach((function(e){if(!(e.material.opacity<.75)&&e.material.castShadow)for(let r in e.faces){let a=e.faces[r];a.hidden||(t.push([a.vertices[2],a.vertices[1],a.vertices[0]]),t.push([a.vertices[0],a.vertices[3],a.vertices[2]]))}}),this,!0),t}_trianglesToOctree(e){let t=e.length;if(t<=9)return this._trianglesToPartition(e);{let r=0,a=0,o=0;for(let s=0;s<t;s++){let t=e[s];r+=t[0].x+t[1].x+t[2].x,a+=t[0].y+t[1].y+t[2].y,o+=t[0].z+t[1].z+t[2].z}r/=t,a/=t,o/=t;let s=[];for(let i=0;i<t;i++){let t=e[i],n=(t[0].x+t[1].x+t[2].x<r?0:1)+2*(t[0].y+t[1].y+t[2].y<a?0:1)+4*(t[0].z+t[1].z+t[2].z<o?0:1);s[n]?s[n].push(t):s[n]=[t]}for(let e=7;e>=0;e--)s[e]||s.splice(e,1);if(1===s.length)return this._trianglesToPartition(e);let i={minx:Number.MAX_VALUE,miny:Number.MAX_VALUE,minz:Number.MAX_VALUE,maxx:-Number.MAX_VALUE,maxy:-Number.MAX_VALUE,maxz:-Number.MAX_VALUE,partitions:s};for(let e=0;e<s.length;e++)s[e]=this._trianglesToOctree(s[e]),i.minx=Math.min(i.minx,s[e].minx),i.miny=Math.min(i.miny,s[e].miny),i.minz=Math.min(i.minz,s[e].minz),i.maxx=Math.max(i.maxx,s[e].maxx),i.maxy=Math.max(i.maxy,s[e].maxy),i.maxz=Math.max(i.maxz,s[e].maxz);return i}}_trianglesToPartition(e){let t={minx:Number.MAX_VALUE,miny:Number.MAX_VALUE,minz:Number.MAX_VALUE,maxx:-Number.MAX_VALUE,maxy:-Number.MAX_VALUE,maxz:-Number.MAX_VALUE,triangles:e},r=e.length;for(let a=0;a<r;a++){let r=e[a];t.minx=Math.min(t.minx,r[0].x,r[1].x,r[2].x),t.miny=Math.min(t.miny,r[0].y,r[1].y,r[2].y),t.minz=Math.min(t.minz,r[0].z,r[1].z,r[2].z),t.maxx=Math.max(t.maxx,r[0].x,r[1].x,r[2].x),t.maxy=Math.max(t.maxy,r[0].y,r[1].y,r[2].y),t.maxz=Math.max(t.maxz,r[0].z,r[1].z,r[2].z)}return t}_aoSidesToOctree(e,t,r){let a=e.vertexBounds,o=[];for(let t=0;t<=1;t++){const s=2*r*t;e.aoSides.nx&&o.push([{x:a.minX-s,y:1e6,z:-1e6},{x:a.minX-s,y:1e6,z:1e6},{x:a.minX-s,y:-1e7,z:0}]),e.aoSides.px&&o.push([{x:a.maxX+s,y:1e6,z:1e6},{x:a.maxX+s,y:1e6,z:-1e6},{x:a.maxX+s,y:-1e7,z:0}]),e.aoSides.ny&&o.push([{x:1e6,y:a.minY-s,z:-1e6},{x:-1e6,y:a.minY-s,z:-1e6},{x:0,y:a.minY-s,z:1e7}]),e.aoSides.py&&o.push([{x:-1e6,y:a.maxY+s,z:-1e6},{x:1e6,y:a.maxY+s,z:-1e6},{x:0,y:a.maxY+s,z:1e7}]),e.aoSides.nz&&o.push([{x:1e6,y:1e6,z:a.minZ-s},{x:-1e6,y:1e6,z:a.minZ-s},{x:0,y:-1e7,z:a.minZ-s}]),e.aoSides.pz&&o.push([{x:-1e6,y:1e6,z:a.maxZ+s},{x:1e6,y:1e6,z:a.maxZ+s},{x:0,y:-1e7,z:a.maxZ+s}])}if(o.length>0){let e=this._trianglesToOctree(o);t={minx:-Number.MAX_VALUE,miny:-Number.MAX_VALUE,minz:-Number.MAX_VALUE,maxx:Number.MAX_VALUE,maxy:Number.MAX_VALUE,maxz:Number.MAX_VALUE,partitions:[t,e]}}return t}_hitsOctree(e,t,r,a,o,s=null){if(s=s??this.octree,!this._hitsBox(e.x,e.y,e.z,a.x,a.y,a.z,s))return!1;if(s.triangles)return this._hitsTriangles(s.triangles,e.x,e.y,e.z,t.x,t.y,t.z,r);for(let i=0;i<s.partitions.length;i++)if(this._hitsOctree(e,t,r,a,o,s.partitions[i]))return!0;return!1}_distanceToOctree(e,t,r,a,o,s=null){if(s=s??this.octree,!this._hitsBox(e.x,e.y,e.z,a.x,a.y,a.z,s))return null;if(s.triangles)return this._distanceToTriangles(s.triangles,e.x,e.y,e.z,t.x,t.y,t.z,r);let i=null;for(let n=0;n<s.partitions.length;n++){let l=this._distanceToOctree(e,t,r,a,o,s.partitions[n]);l&&(i=Math.min(i??r,l))}return i}_hitsBox(e,t,r,a,o,s,i){if(e<i.minx&&a<i.minx)return!1;if(e>i.maxx&&a>i.maxx)return!1;if(t<i.miny&&o<i.miny)return!1;if(t>i.maxy&&o>i.maxy)return!1;if(r<i.minz&&s<i.minz)return!1;if(r>i.maxz&&s>i.maxz)return!1;let n=a-e,l=o-t,c=s-r,d=i.maxx-i.minx,p=i.maxy-i.miny,m=i.maxz-i.minz,u=2*e+n-(i.minx+i.maxx),h=2*t+l-(i.miny+i.maxy),f=2*r+c-(i.minz+i.maxz),x=Math.abs(n),g=Math.abs(l),y=Math.abs(c);return!(Math.abs(u)>d+x)&&(!(Math.abs(h)>p+g)&&(!(Math.abs(f)>m+y)&&(!(Math.abs(l*f-c*h)>p*y+m*g+Number.EPSILON)&&(!(Math.abs(c*u-n*f)>m*x+d*y+Number.EPSILON)&&!(Math.abs(n*h-l*u)>d*g+p*x+Number.EPSILON)))))}_hitsTriangles(e,t,r,a,o,s,i,n){for(let l=0;l<e.length;l++){let c=e[l];if((this._triangleDistance(c[0],c[1],c[2],t,r,a,o,s,i)??n)<n)return!0}return!1}_distanceToTriangles(e,t,r,a,o,s,i,n){let l=null;for(let c=0;c<e.length;c++){let d=e[c],p=this._triangleDistance(d[0],d[1],d[2],t,r,a,o,s,i);p&&(l=Math.min(l||n,p))}return l}_triangleDistance(e,t,r,a,o,s,i,n,l){let c=t.x-e.x,d=t.y-e.y,p=t.z-e.z,m=r.x-e.x,u=r.y-e.y,h=r.z-e.z,f=n*h-l*u,x=l*m-i*h,g=i*u-n*m,y=c*f+d*x+p*g;if(y>-Number.EPSILON&&y<Number.EPSILON)return null;let v=1/y,b=a-e.x,z=o-e.y,w=s-e.z,M=v*(b*f+z*x+w*g);if(M<0||M>1)return null;let S=z*p-w*d,_=w*c-b*p,P=b*d-z*c,E=v*(i*S+n*_+l*P);if(E<0||M+E>1)return null;let F=v*(m*S+u*_+h*P);return F<=Number.EPSILON?null:F}}class AOCalculator{static calculateAmbientOcclusion(e){if(!(e.ao||e.materials.find((function(e){return e.ao}))))return;let t=new Octree(e),r=e.aoSamples,a=this._generateFibonacciSamples(r),o={},s={x:0,y:0,z:0},i={x:0,y:0,z:0};const n=Math.min(e.scale.x,e.scale.y,e.scale.z),l=.1*n,c=1-l;e.voxels.forEach((function(d){let p=d.material.ao||(d.material.lights?e.ao:void 0);if(d.material.quickAo||!p||0===p.maxDistance||0===p.intensity||p.angle<1||0===d.material.opacity)return;let m=p.maxDistance*n,u=p.intensity,h=Math.cos(p.angle/180*Math.PI);for(let e in d.faces){let n=d.faces[e];if(!n.hidden){n.ao[0]=0,n.ao[1]=0,n.ao[2]=0,n.ao[3]=0;for(let e=0;e<4;e++){let d=n.vertices[e],p=n.normals[e],f=`${d.x}|${d.y}|${d.z}|${p.x}|${p.y}|${p.z}`,x=o[f];if(x){n.ao[e]=x;continue}let g=n.vertices[(e+2)%4];s.x=d.x*c+g.x*l+p.x*l,s.y=d.y*c+g.y*l+p.y*l,s.z=d.z*c+g.z*l+p.z*l;let y=0,v=0;for(let e=0;e<r;e++){let r=a[e];r.x*p.x+r.y*p.y+r.z*p.z<=h||(i.x=s.x+r.x*m,i.y=s.y+r.y*m,i.z=s.z+r.z*m,y+=t._distanceToOctree(s,r,m,i,n)??m,v++)}0===v?n.ao[e]=0:(y=Math.max(Math.min(y/m/v,1),0),n.ao[e]=1-Math.pow(y,u)),o[f]=n.ao[e]}}}}),this,!0)}static _generateFibonacciSamples(e){let t=[],r=(2-(Math.sqrt(5)+1)/2)*(2*Math.PI);for(let a=1;a<=e;++a){let o=Math.asin(2*a/(e+1)-1),s=r*a,i=Math.cos(s)*Math.cos(o),n=Math.sin(o),l=Math.sin(s)*Math.cos(o);t.push({x:i,y:n,z:l})}return t}}class LightsCalculator{static calculateLights(e){if(0===e.lights.length)return;const t=Math.min(e.scale.x,e.scale.y,e.scale.z);let r=new Octree(e),a=new Matrix;a=Matrix.multiply(a,Matrix.translate(e.position.x,e.position.y,e.position.z)),a=Matrix.multiply(a,Matrix.rotate(e.rotation.z,0,0,1)),a=Matrix.multiply(a,Matrix.rotate(e.rotation.y,0,1,0)),a=Matrix.multiply(a,Matrix.rotate(e.rotation.x,1,0,0)),a=Matrix.multiply(a,Matrix.scale(e.scale.x,e.scale.y,e.scale.z));let o=new Matrix;o=Matrix.multiply(o,Matrix.rotate(e.rotation.z,0,0,1)),o=Matrix.multiply(o,Matrix.rotate(e.rotation.y,0,1,0)),o=Matrix.multiply(o,Matrix.rotate(e.rotation.x,1,0,0)),o=Matrix.multiply(o,Matrix.scale(e.scale.x,e.scale.y,e.scale.z)),e.actualLights=[],e.lights.forEach((function(t){if(t.atVoxel)this.addLightsAtVoxel(e,e.actualLights,t);else{let r={color:t.color,intensity:t.intensity,distance:t.distance*(e.scale.x+e.scale.y+e.scale.z)/3,size:t.size*(e.scale.x+e.scale.y+e.scale.z)/3,detail:t.detail,castShadow:t.castShadow,data:t.data};t.direction&&(r.direction={x:t.direction.x,y:t.direction.y,z:t.direction.z},o.transformPoint(r.direction),r.normalizedDirection=e._normalize(r.direction)),t.position&&(r.position={x:t.position.x,y:t.position.y,z:t.position.z},a.transformPoint(r.position)),e.actualLights.push(r)}}),this);let s={x:0,y:0,z:0},i={x:0,y:0,z:0},n={x:0,y:0,z:0},l={};e.voxels.forEach((function(a){if(!a.material.lights)return;let o=Number.MAX_VALUE,c=Number.MAX_VALUE,d=Number.MAX_VALUE,p=-Number.MAX_VALUE,m=-Number.MAX_VALUE,u=-Number.MAX_VALUE;for(let e in a.faces){let t=a.faces[e];o=Math.min(o,t.vertices[0].x,t.vertices[1].x,t.vertices[2].x,t.vertices[3].x),p=Math.max(p,t.vertices[0].x,t.vertices[1].x,t.vertices[2].x,t.vertices[3].x),c=Math.min(c,t.vertices[0].y,t.vertices[1].y,t.vertices[2].y,t.vertices[3].y),m=Math.max(m,t.vertices[0].y,t.vertices[1].y,t.vertices[2].y,t.vertices[3].y),d=Math.min(d,t.vertices[0].z,t.vertices[1].z,t.vertices[2].z,t.vertices[3].z),u=Math.max(u,t.vertices[0].z,t.vertices[1].z,t.vertices[2].z,t.vertices[3].z)}for(let e in a.faces){a.faces[e].light=[]}for(let h in a.faces){let f=a.faces[h];for(let h=0;h<4;h++){let x=f.vertices[h],g=f.normals[h],y=`${x.x}|${x.y}|${x.z}|${g.x}|${g.y}|${g.z}`,v=l[y],b=!1;v?b="low"===e.shadowQuality:(v={r:0,g:0,b:0,c:0},l[y]=v),f.light[h]=v,b||(v.c++,e.actualLights.forEach((function(e){if(e.position&&e.distance){if(o-e.distance>=e.position.x||p+e.distance<=e.position.x)return;if(c-e.distance>=e.position.y||m+e.distance<=e.position.y)return;if(d-e.distance>=e.position.z||u+e.distance<=e.position.z)return}let l=e.intensity??1,y=e.normalizedDirection?.x,b=e.normalizedDirection?.y,z=e.normalizedDirection?.z,w=Number.MAX_VALUE;if(e.position){let t=e.position.x-x.x,r=e.position.y-x.y,a=e.position.z-x.z;w=Math.sqrt(t*t+r*r+a*a),Math.abs(w)<1e-6&&(w=1),y=t/w,b=r/w,z=a/w}if("number"==typeof y&&(l=e.intensity*Math.max(g.x*y+g.y*b+g.z*z,0)),e.position&&e.distance&&(l*=1-Math.min(w/e.distance,1)),e.position||e.direction){let o=f.vertices[(h+2)%4];s.x=.75*x.x+.25*o.x+g.x*t*.25,s.y=.75*x.y+.25*o.y+g.y*t*.25,s.z=.75*x.z+.25*o.z+g.z*t*.25,e.position?(i.x=e.position.x,i.y=e.position.y,i.z=e.position.z):(i.x=1e4*e.direction.x,i.y=1e4*e.direction.y,i.z=1e4*e.direction.z),n.x=i.x-s.x,n.y=i.y-s.y,n.z=i.z-s.z,w=Math.sqrt(n.x*n.x+n.y*n.y+n.z*n.z),n.x/=w,n.y/=w,n.z/=w,n.x*g.x+n.y*g.y+n.z*g.z>0&&(e.castShadow&&a.material.receiveShadow&&r._hitsOctree(s,n,w,i,f)||(v.r+=e.color.r*l,v.g+=e.color.g*l,v.b+=e.color.b*l))}else v.r+=e.color.r*l,v.g+=e.color.g*l,v.b+=e.color.b*l}),this))}}}),this,!0);for(const e in l){let t=l[e];t.r/=t.c,t.g/=t.c,t.b/=t.c}}static addLightsAtVoxel(e,t,r){let a=r.atVoxel,o=r.color,s=r.intensity,i=r.distance*(e.scale.x+e.scale.y+e.scale.z)/3,n=r.size*(e.scale.x+e.scale.y+e.scale.z)/3,l=r.detail,c=r.castShadow,d=r.data;e.voxels.forEach((function(e){if(e.color.id==a){let r={colorId:a,color:o,intensity:s,distance:i,size:n,detail:l,castShadow:c,data:d};this.determineLightPositionAtVoxelCenter(e,r)&&t.push(r)}}),this)}static determineLightPositionAtVoxelCenter(e,t){let r=0,a=0,o=0,s=0;for(let t in e.faces){let i=e.faces[t];for(let e=0;e<4;e++){let t=i.vertices[e];r+=t.x,a+=t.y,o+=t.z,s++}}return s>0&&(t.position={x:r/s,y:a/s,z:o/s},!0)}}class QuickAOCalculator{static calculateQuickAmbientOcclusion(e){(e.quickAo||e.materials.find((function(e){return e.quickAo})))&&e.voxels.forEach((function(t){let r=t.material.quickAo||(t.material.lights?e.quickAo:void 0);if(t.material.ao||!r||0===r.intensity)return;let a=t.group.id,o=r.intensity;for(let r in t.faces){let s=t.faces[r];if(s.hidden)continue;let i=SVOX._AONEIGHBORS[r],n=this._isObstructed(e,a,i.top.faces,t.x+i.top.x,t.y+i.top.y,t.z+i.top.z),l=this._isObstructed(e,a,i.topRight.faces,t.x+i.topRight.x,t.y+i.topRight.y,t.z+i.topRight.z),c=this._isObstructed(e,a,i.right.faces,t.x+i.right.x,t.y+i.right.y,t.z+i.right.z),d=this._isObstructed(e,a,i.bottomRight.faces,t.x+i.bottomRight.x,t.y+i.bottomRight.y,t.z+i.bottomRight.z),p=this._isObstructed(e,a,i.bottom.faces,t.x+i.bottom.x,t.y+i.bottom.y,t.z+i.bottom.z),m=this._isObstructed(e,a,i.bottomLeft.faces,t.x+i.bottomLeft.x,t.y+i.bottomLeft.y,t.z+i.bottomLeft.z),u=this._isObstructed(e,a,i.left.faces,t.x+i.left.x,t.y+i.left.y,t.z+i.left.z),h=this._isObstructed(e,a,i.topLeft.faces,t.x+i.topLeft.x,t.y+i.topLeft.y,t.z+i.topLeft.z),f=1-.45*Math.min(1,p+u+m),x=1-.45*Math.min(1,n+u+h),g=1-.45*Math.min(1,n+c+l),y=1-.45*Math.min(1,p+c+d);s.ao[0]=1-Math.pow(f,o),s.ao[1]=1-Math.pow(x,o),s.ao[2]=1-Math.pow(g,o),s.ao[3]=1-Math.pow(y,o)}}),this,!0)}static _isObstructed(e,t,r,a,o,s){if(e.aoSides){let t=e.voxels.bounds;if(a<t.minX&&e.aoSides.nx)return 1;if(a>t.maxX-1&&e.aoSides.px)return 1;if(o<t.minY&&e.aoSides.ny)return 1;if(o>t.maxY-1&&e.aoSides.py)return 1;if(s<t.minZ&&e.aoSides.nz)return 1;if(s>t.maxZ-1&&e.aoSides.pz)return 1}let i=e.voxels.getVoxel(a,o,s,t),n=0;if(i){let e=i.faces[r[0]];e&&!e.hidden&&(n+=1);let t=r[1]?i.faces[r[1]]:null;t&&!t.hidden&&(n+=1),n/=r.length}return n}}class ColorCombiner{static combineColors(e){let t=!!e.materials.find((e=>e.colors.length>1&&e.fade));e.voxels.forEach((function(r){let a=t&&r.material.fade&&r.material.colors.length>1;for(let t in r.faces){let o=r.faces[t];o&&(a?SVOX.colorManagement?this._fadeFaceColorsManaged(r,o):this._fadeFaceColors(r,o):delete o.vertexColors,this._combineFaceColors(e,r,o))}}),this,!0)}static _fadeFaceColorsManaged(e,t){t.vertexColors=[null,null,null,null];for(let r=0;r<4;r++){let a=t.vertices[r],o=0,s=0,i=0,n=0;for(let t=0;t<a.colors.length;t++){let r=a.colors[t];r.material===e.material&&(o+=r.r*r.r,s+=r.g*r.g,i+=r.b*r.b,n++)}t.vertexColors[r]=Color.fromRgb(Math.sqrt(o/n),Math.sqrt(s/n),Math.sqrt(i/n))}}static _fadeFaceColors(e,t){t.vertexColors=[null,null,null,null];for(let r=0;r<4;r++){let a=t.vertices[r],o=0,s=0,i=0,n=0;for(let t=0;t<a.colors.length;t++){let r=a.colors[t];r.material===e.material&&(o+=r.r,s+=r.g,i+=r.b,n++)}t.vertexColors[r]=Color.fromRgb(o/n,s/n,i/n)}}static _combineFaceColors(e,t,r){if(1!==t.material.colorCount||t.material.ao||e.ao||t.material.quickAo||e.quickAo||0!==e.lights.length)if(!(t.material.colorCount>1)||t.material.ao||e.ao||t.material.quickAo||e.quickAo||0!==e.lights.length||r.vertexColors){r.vertexColors=r.vertexColors||[t.color.clone(),t.color.clone(),t.color.clone(),t.color.clone()];let a=r.vertexColors,o=r.light||[{r:1,g:1,b:1},{r:1,g:1,b:1},{r:1,g:1,b:1},{r:1,g:1,b:1}],s=r.ao;for(let r=0;r<4;r++){let i=a[r],n=o[r],l=s[r],c=(t.material.quickAo||t.material.ao||e.quickAo||e.ao)?.color||i;i.r=n.r*(1-l)*i.r+c.r*l,i.g=n.g*(1-l)*i.g+c.g*l,i.b=n.b*(1-l)*i.b+c.b*l}}else r.color=t.color;else;}}class UVAssigner{static assignUVs(e){let t={x:0,y:0},r={x:0,y:0};e.voxels.forEach((function(a){let o=!1,s=1,i=1,n=0,l=0,c=a.group.bounds,d=Math.max(a.group.bounds.size.x,a.group.bounds.size.y,a.group.bounds.size.z)-1,p=a.material.settings;!o&&p.mapTransform&&-1!==p.mapTransform.uscale?(r.uscale=p.mapTransform.uscale,r.vscale=p.mapTransform.vscale):(r.uscale=1,r.vscale=1);let m=p.map||p.normalMap||p.roughnessMap||p.metalnessMap||p.displacementMap||p.alphaMap||p.emissiveMap||p.thicknessMap||p.transmissionMap||p.specularColorMap||p.specularIntensityMap||p.specularMap||p.clearcoatMap||p.clearcoatNormalMap||p.clearcoatRoughnessMap;if(m){let a=e.textures.getById(m),c=a?.borderOffset??.5;a?.size?(t.x=a.size.x,t.y=a.size.y):(t.x=1024,t.y=1024),n=1/t.x*c*r.uscale,l=1/t.y*c*r.vscale,(p.map&&e.textures.getById(p.map).cube||p.normalMap&&e.textures.getById(p.normalMap).cube||p.roughnessMap&&e.textures.getById(p.roughnessMap).cube||p.metalnessMap&&e.textures.getById(p.metalnessMap).cube||p.displacementMap&&e.textures.getById(p.displacementMap).cube||p.alphaMap&&e.textures.getById(p.alphaMap).cube||p.emissiveMap&&e.textures.getById(p.emissiveMap).cube||p.thicknessMap&&e.textures.getById(p.thicknessMap).cube||p.transmissionMap&&e.textures.getById(p.transmissionMap).cube||p.specularColorMap&&e.textures.getById(p.specularColorMap).cube||p.specularIntensityMap&&e.textures.getById(p.specularIntensityMap).cube||p.specularMap&&e.textures.getById(p.specularMap).cube||p.clearcoatMap&&e.textures.getById(p.clearcoatMap).cube||p.clearcoatNormalMap&&e.textures.getById(p.clearcoatNormalMap).cube||p.clearcoatRoughnessMap&&e.textures.getById(p.clearcoatRoughnessMap).cube)&&(o=!0,s=1/4/d,i=.5/d,n=4/t.x*c*d,l=2/t.y*c*d)}for(let t in a.faces){let r=a.faces[t],d=SVOX._FACEUVDEFS[t];r.uv=[];let p=a[d.udir]-c[d.uminbound],m=a[d.vdir]-c[d.vminbound],u=this.adjacentVoxelIsDifferentMaterial(e,a,d.top)?l:0,h=this.adjacentVoxelIsDifferentMaterial(e,a,d.right)?n:0,f=this.adjacentVoxelIsDifferentMaterial(e,a,d.bottom)?l:0,x=this.adjacentVoxelIsDifferentMaterial(e,a,d.left)?n:0,g=(o?d.cubeu:0)+(p+x)*s*d.usign,y=(o?d.cubeu:0)+(p-h+1)*s*d.usign,v=(o?d.cubev:0)+(m-u+1)*i*d.vsign,b=(o?d.cubev:0)+(m+f)*i*d.vsign;o||(g+y<0&&(g=-g,y=-y),v+b<0&&(v=-v,b=-b)),r.uv[d.order[0]]={u:g,v:b},r.uv[d.order[1]]={u:g,v:v},r.uv[d.order[2]]={u:y,v:v},r.uv[d.order[3]]={u:y,v:b}}}),this,!0)}static adjacentVoxelIsDifferentMaterial(e,t,r){let a=e.voxels.getVoxel(t.x+r.x,t.y+r.y,t.z+r.z,t.group.id);return a?.material.baseId!==t.material.baseId}}class Simplifier{static simplify(e){e.groups.forEach((function(t){if(!(e.simplify||e.materials.find((function(e){return e.simplify}))))return;let r={model:e},a={model:e},o={model:e},s={model:e},i=function(){r.lastVoxel=null,a.lastVoxel=null,o.lastVoxel=null,s.lastVoxel=null};for(let n=e.voxels.minX;n<=e.voxels.maxX;n++)for(let l=e.voxels.minZ;l<=e.voxels.maxZ;l++)for(let c=e.voxels.minY;c<=e.voxels.maxY;c++){let d=e.voxels.getVoxel(n,c,l,t.id);d?(this._mergeFaces(r,d,"x","z","y","nx",0,1,2,3),this._mergeFaces(a,d,"x","z","y","px",0,1,2,3),this._mergeFaces(o,d,"x","z","y","nz",0,1,2,3),this._mergeFaces(s,d,"x","z","y","pz",0,1,2,3)):i()}i();for(let n=e.voxels.minX;n<=e.voxels.maxX;n++)for(let l=e.voxels.minY;l<=e.voxels.maxY;l++)for(let c=e.voxels.minZ;c<=e.voxels.maxZ;c++){let d=e.voxels.getVoxel(n,l,c,t.id);d?(this._mergeFaces(r,d,"x","y","z","nx",1,2,3,0),this._mergeFaces(a,d,"x","y","z","px",3,0,1,2),this._mergeFaces(o,d,"x","y","z","ny",0,1,2,3),this._mergeFaces(s,d,"x","y","z","py",2,3,0,1)):i()}i();for(let n=e.voxels.minY;n<=e.voxels.maxY;n++)for(let l=e.voxels.minZ;l<=e.voxels.maxZ;l++)for(let c=e.voxels.minX;c<=e.voxels.maxX;c++){let d=e.voxels.getVoxel(c,n,l,t.id);d?(this._mergeFaces(r,d,"y","z","x","ny",1,2,3,0),this._mergeFaces(a,d,"y","z","x","py",1,2,3,0),this._mergeFaces(o,d,"y","z","x","nz",3,0,1,2),this._mergeFaces(s,d,"y","z","x","pz",1,2,3,0)):i()}}),this)}static _mergeFaces(e,t,r,a,o,s,i,n,l,c){let d=null;if(t&&(d=t.faces[s]),t&&e.lastVoxel&&(!0===t.material.simplify||void 0===t.material.simplify&&!0===e.model.simplify)&&d&&e.lastFace&&t.color===e.lastVoxel.color&&t[r]===e.lastVoxel[r]&&t[a]===e.lastVoxel[a]){let p=d.normals,m=e.lastFace.normals,u=d.vertexColors,h=e.lastFace.vertexColors,f=d.vertices,x=e.lastFace.vertices,g=d.ao,y=e.lastFace.ao,v=Math.sqrt((f[n].x-f[i].x)*(f[n].x-f[i].x)+(f[n].y-f[i].y)*(f[n].y-f[i].y)+(f[n].z-f[i].z)*(f[n].z-f[i].z)),b=Math.sqrt((f[n].x-x[i].x)*(f[n].x-x[i].x)+(f[n].y-x[i].y)*(f[n].y-x[i].y)+(f[n].z-x[i].z)*(f[n].z-x[i].z)),z=0===b?.5:v/b,w=Math.sqrt((f[l].x-f[c].x)*(f[l].x-f[c].x)+(f[l].y-f[c].y)*(f[l].y-f[c].y)+(f[l].z-f[c].z)*(f[l].z-f[c].z)),M=Math.sqrt((f[l].x-x[c].x)*(f[l].x-x[c].x)+(f[l].y-x[c].y)*(f[l].y-x[c].y)+(f[l].z-x[c].z)*(f[l].z-x[c].z)),S=0===M?.5:w/M;if((t.material.type===SVOX.MATBASIC||this._normalEquals(p[0],m[0])&&this._normalEquals(p[1],m[1])&&this._normalEquals(p[2],m[2])&&this._normalEquals(p[3],m[3]))&&(!u&&!h||this._colorEquals(u[0],h[0])&&this._colorEquals(u[1],h[1])&&this._colorEquals(u[2],h[2])&&this._colorEquals(u[3],h[3]))&&g[0]===y[0]&&g[1]===y[1]&&g[2]===y[2]&&g[3]===y[3]&&Math.abs(x[n][r]-(1-z)*f[n][r]-z*x[i][r])<=10*Number.EPSILON&&Math.abs(x[n][a]-(1-z)*f[n][a]-z*x[i][a])<=10*Number.EPSILON&&Math.abs(x[n][o]-(1-z)*f[n][o]-z*x[i][o])<=10*Number.EPSILON&&Math.abs(x[l][r]-(1-S)*f[l][r]-S*x[c][r])<=10*Number.EPSILON&&Math.abs(x[l][a]-(1-S)*f[l][a]-S*x[c][a])<=10*Number.EPSILON&&Math.abs(x[l][o]-(1-S)*f[l][o]-S*x[c][o])<=10*Number.EPSILON)return x[n]=f[n],x[l]=f[l],e.lastFace.uv[n]=d.uv[n],e.lastFace.uv[l]=d.uv[l],e.lastFace.flatNormals[n]=d.flatNormals[n],e.lastFace.flatNormals[l]=d.flatNormals[l],e.lastFace.smoothNormals[n]=d.smoothNormals[n],e.lastFace.smoothNormals[l]=d.smoothNormals[l],e.lastFace.bothNormals[n]=d.bothNormals[n],e.lastFace.bothNormals[l]=d.bothNormals[l],e.lastFace.sideNormals[n]=d.sideNormals[n],e.lastFace.sideNormals[l]=d.sideNormals[l],void delete t.faces[s]}e.lastVoxel=t,e.lastFace=d}static _normalEquals(e,t){return Math.abs(e.x-t.x)<.01&&Math.abs(e.y-t.y)<.01&&Math.abs(e.z-t.z)<.01}static _colorEquals(e,t){return e.r===t.r&&e.g===t.g&&e.b===t.b}static _faceVerticesToString(e){return`[${this._vertexToString(e[0],0)},${this._vertexToString(e[1],0)},${this._vertexToString(e[2],0)},${this._vertexToString(e[3],0)}]`}static _vertexToString(e,t){return`{${e.x.toFixed(t)},${e.y.toFixed(t)},${e.z.toFixed(t)}}`}}class FaceAligner{static alignFaceDiagonals(e){e.vertices.forEach((function(e){e.count=0}),this);let t=.1*Math.min(e.scale.x,e.scale.y,e.scale.z);t*=t,e.voxels.forEach((function(e){for(let r in e.faces){let a=e.faces[r];if(a.hidden)continue;a.vertices[0].count++,a.vertices[1].count++,a.vertices[2].count++,a.vertices[3].count++;let o=(a.vertices[0].x+a.vertices[2].x)/2,s=(a.vertices[0].y+a.vertices[2].y)/2,i=(a.vertices[0].z+a.vertices[2].z)/2,n=(a.vertices[1].x-o)*(a.vertices[1].x-o)+(a.vertices[1].y-s)*(a.vertices[1].y-s)+(a.vertices[1].z-i)*(a.vertices[1].z-i),l=(a.vertices[3].x-o)*(a.vertices[3].x-o)+(a.vertices[3].y-s)*(a.vertices[3].y-s)+(a.vertices[3].z-i)*(a.vertices[3].z-i),c=(a.vertices[1].x+a.vertices[3].x)/2,d=(a.vertices[1].y+a.vertices[3].y)/2,p=(a.vertices[1].z+a.vertices[3].z)/2,m=(a.vertices[0].x-c)*(a.vertices[0].x-c)+(a.vertices[0].y-d)*(a.vertices[0].y-d)+(a.vertices[0].z-p)*(a.vertices[0].z-p),u=(a.vertices[2].x-c)*(a.vertices[2].x-c)+(a.vertices[2].y-d)*(a.vertices[2].y-d)+(a.vertices[2].z-p)*(a.vertices[2].z-p);if(n<t||l<t)a.vertices.push(a.vertices.shift()),a.flatNormals.push(a.flatNormals.shift()),a.smoothNormals.push(a.smoothNormals.shift()),a.bothNormals.push(a.bothNormals.shift()),a.sideNormals.push(a.sideNormals.shift()),a.ao.push(a.ao.shift()),a.uv.push(a.uv.shift()),a.vertexColors&&a.vertexColors.push(a.vertexColors.shift());else if(m<t||u<t);else if(a.ao&&Math.min(a.ao[0],a.ao[1],a.ao[2],a.ao[3])!==Math.max(a.ao[0],a.ao[1],a.ao[2],a.ao[3])){Math.abs(a.ao[0]-a.ao[2])<Math.abs(a.ao[1]-a.ao[3])&&(a.vertices.push(a.vertices.shift()),a.flatNormals.push(a.flatNormals.shift()),a.smoothNormals.push(a.smoothNormals.shift()),a.bothNormals.push(a.bothNormals.shift()),a.sideNormals.push(a.sideNormals.shift()),a.ao.push(a.ao.shift()),a.uv.push(a.uv.shift()),a.vertexColors&&a.vertexColors.push(a.vertexColors.shift()))}else{let e=this._getVertexSum(a.vertices[0]);for(;this._getVertexSum(a.vertices[1])<e||this._getVertexSum(a.vertices[2])<e||this._getVertexSum(a.vertices[3])<e;)a.vertices.push(a.vertices.shift()),a.flatNormals.push(a.flatNormals.shift()),a.smoothNormals.push(a.smoothNormals.shift()),a.bothNormals.push(a.bothNormals.shift()),a.sideNormals.push(a.sideNormals.shift()),a.ao.push(a.ao.shift()),a.uv.push(a.uv.shift()),a.vertexColors&&a.vertexColors.push(a.vertexColors.shift()),e=this._getVertexSum(a.vertices[0])}}}),this,!0)}static _getVertexSum(e){let t=e.group.originOffset;return Math.abs(e.x-t.x)+Math.abs(e.y-t.y)+Math.abs(e.z-t.z)}}class SvoxMeshGenerator{static generate(e){let t={materials:[],groups:[],indices:[],positions:[],normals:[],colors:[],uvs:null,data:null};e.prepareForWrite(!1);let r=!1;if(e.materials.baseMaterials.forEach((function(e){r=r||e.hasMap}),this),this.calculateAll(e,r),r=!1,e.materials.baseMaterials.forEach((function(a){a.colorUsageCount>0&&(a.index=t.materials.length,t.materials.push(SvoxMeshGenerator._generateMaterial(a.settings,e)),r=r||a.hasMap)}),this),r&&(t.uvs=[]),e.data){t.data=[];for(let r=0;r<e.data.length;r++)t.data.push({name:e.data[r].name,width:e.data[r].values.length,values:[]})}return SvoxMeshGenerator._generateAll(e,t),SvoxMeshGenerator._generateLights(e,t),t=SvoxMeshGenerator._toIndexed(t),t}static calculateAll(e,t){GroupCloner.cloneGroups(e),FaceCreator.createAllFaces(e);let r=Deformer.maximumDeformCount(e);r>0&&VertexLinker.linkVertices(e.voxels),e.determineBoundsForAllGroups(),ShapeModifier.modify(e),Deformer.deform(e,r),Deformer.warpAndScatter(e),e.determineBoundsForAllGroups(),SkewAndScaleAxisModifier.modify(e),NormalsCalculator.calculateNormals(e),e.determineBoundsForAllGroups(!0),VertexTransformer.transformVertices(e),e.determineBoundsForAllGroups(),LightsCalculator.calculateLights(e),AOCalculator.calculateAmbientOcclusion(e),QuickAOCalculator.calculateQuickAmbientOcclusion(e),ColorCombiner.combineColors(e),t&&UVAssigner.assignUVs(e),Simplifier.simplify(e),e.determineBoundsForAllGroups(),FaceAligner.alignFaceDiagonals(e)}static _toIndexed(e){let t=e.colors&&e.colors.length>0,r=e.uvs&&e.uvs.length>0,a=!!e.data,o=this._determineIndices(e,t,r,a),s={materials:e.materials,groups:e.groups,indices:new Uint32Array(e.indices.length),positions:new Float32Array(3*o),normals:new Float32Array(3*o),colors:t?new Float32Array(3*o):null,uvs:r?new Float32Array(2*o):null,data:a?[]:null};if(e.data)for(let t=0;t<e.data.length;t++){let r=e.data[t];s.data.push({name:r.name,width:r.width,values:new Float32Array(o*r.width)})}let i=0;for(let o=0;o<e.indices.length;o++)if(s.indices[o]=e.indices[o],e.indices[o]===i){if(s.positions[3*i+0]=e.positions[3*o+0],s.positions[3*i+1]=e.positions[3*o+1],s.positions[3*i+2]=e.positions[3*o+2],s.normals[3*i+0]=e.normals[3*o+0],s.normals[3*i+1]=e.normals[3*o+1],s.normals[3*i+2]=e.normals[3*o+2],t&&(s.colors[3*i+0]=e.colors[3*o+0],s.colors[3*i+1]=e.colors[3*o+1],s.colors[3*i+2]=e.colors[3*o+2]),r&&(s.uvs[2*i+0]=e.uvs[2*o+0],s.uvs[2*i+1]=e.uvs[2*o+1]),a)for(let t=0;t<e.data.length;t++){let r=e.data[t],a=s.data[t];for(let e=0;e<r.width;e++)a.values[i*r.width+e]=r.values[o*r.width+e]}i++}return s}static _determineIndices(e,t,r,a){let o={},s=-1,i=0,n=e.positions.length/3;for(let l=0;l<n;l++){let n=2*l,c=3*l,d=`${e.positions[c]}|${e.positions[c+1]}|${e.positions[c+2]}|${e.normals[c]}|${e.normals[c+1]}|${e.normals[c+2]}`;if(t&&(d+=`|${e.colors[c]}|${e.colors[c+1]}|${e.colors[c+2]}`),r&&(d+=`|${e.uvs[n]}|${e.uvs[n+1]}`),a)for(let t=0;t<e.data.length;t++){let r=e.data[t];for(let e=0;e<r.width;e++)d+=`|${r.values[l*r.width+e]}`}let p=o[d];void 0===p&&(o[d]=++s,p=s,i++),e.indices[l]=p}return i}static _generateMaterial(e,t){let r;r="function"==typeof structuredClone?structuredClone(e):JSON.parse(JSON.stringify(e)),r.wireframe=r.wireframe??t.wireframe,r.vertexColors=!1,r.type!==SVOX.MATNORMAL&&(r.vertexColors=!0,r.color=this._createColor(Color.fromHex("#FFF")));let a=t.textures,o=Math.max(t.size.x,t.size.y,t.size.z)-1;for(const e in r){let t=r[e];r[e]&&void 0!==t&&("emissive"===e||"specular"===e||"specularColor"===e||"attenuationColor"===e?r[e]=this._createColor(t):"envMap"===e||"matcap"===e?r[e]=this._createMap(r[e],null,a,o):("map"===e||e.endsWith("Map"))&&(r[e]=this._createMap(r[e],r.mapTransform,a,o)))}return delete r.mapTransform,r}static _createMap(e,t,r,a){let o=r.getById(e);return o.cube?{image:o.image,uscale:1,vscale:1,uoffset:0,voffset:0,rotation:0}:t?{image:o.image,uscale:-1===t.uscale?a:t.uscale,vscale:-1===t.vscale?a:t.vscale,uoffset:t.uoffset,voffset:t.voffset,rotation:t.rotation}:{image:o.image}}static _generateLights(e,t){if(e.lights.visible){let r={x:0,y:1,z:0},a={x:0,y:0,z:-1},o={x:1,y:0,z:0},s={x:0,y:0,z:1},i={x:-1,y:0,z:0},n={x:0,y:-1,z:0},l=t.positions.length;e.actualLights.forEach((function(l){if(l.position&&l.size>0){let c=l.size/2,d=l.detail,p=l.data??e.data,m=this._createColor(l.color);SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,a,o,r,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,o,s,r,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,s,i,r,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,i,a,r,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,a,n,o,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,o,n,s,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,s,n,i,t),SvoxMeshGenerator._generateLightFace(l.position,m,c,d,p,i,n,a,t)}}),this);let c=t.positions.length;t.groups.push({start:l/3,count:(c-l)/3,materialIndex:0})}}static _generateLightFace(e,t,r,a,o,s,i,n,l){if(0===a){if(l.positions.push(e.x+n.x*r,e.y+n.y*r,e.z+n.z*r),l.positions.push(e.x+i.x*r,e.y+i.y*r,e.z+i.z*r),l.positions.push(e.x+s.x*r,e.y+s.y*r,e.z+s.z*r),l.normals.push(0,0,1),l.normals.push(0,0,1),l.normals.push(0,0,1),l.colors.push(t.r,t.g,t.b),l.colors.push(t.r,t.g,t.b),l.colors.push(t.r,t.g,t.b),l.uvs&&(l.uvs.push(0,0),l.uvs.push(0,0),l.uvs.push(0,0)),l.data)for(let e=0;e<3;e++)for(let e=0;e<o.length;e++)for(let t=0;t<o[e].values.length;t++)l.data[e].values.push(o[e].values[t])}else{let c=SvoxMeshGenerator._normalize({x:(i.x+s.x)/2,y:(i.y+s.y)/2,z:(i.z+s.z)/2}),d=SvoxMeshGenerator._normalize({x:(i.x+n.x)/2,y:(i.y+n.y)/2,z:(i.z+n.z)/2}),p=SvoxMeshGenerator._normalize({x:(s.x+n.x)/2,y:(s.y+n.y)/2,z:(s.z+n.z)/2});SvoxMeshGenerator._generateLightFace(e,t,r,a-1,o,c,i,d,l),SvoxMeshGenerator._generateLightFace(e,t,r,a-1,o,s,c,p,l),SvoxMeshGenerator._generateLightFace(e,t,r,a-1,o,p,d,n,l),SvoxMeshGenerator._generateLightFace(e,t,r,a-1,o,c,d,p,l)}}static _generateAll(e,t){let r=SvoxMeshGenerator._getAllShells(e);e.materials.baseMaterials.forEach((function(a){if(a.colorUsageCount>0){let o=t.positions.length;e.voxels.forEach((function(o){o.material.index===a.index&&SvoxMeshGenerator._generateVoxel(e,o,t),r.forEach((function(r){r.material.index===a.index&&r.voxelMaterial===o.color.material&&SvoxMeshGenerator._generateVoxelShell(e,o,t,r)}),this)}),this,!0);let s=t.positions.length;o!==s&&t.groups.push({start:o/3,count:(s-o)/3,materialIndex:a.index})}}),this)}static _generateVoxel(e,t,r){for(let a=0;a<SVOX._FACES.length;a++){let o=t.faces[SVOX._FACES[a]];o&&!o.hidden&&SvoxMeshGenerator._generateVoxelFace(e,t,o,r)}}static _generateVoxelFace(e,t,r,a){let o,s,i,n,l,c,d,p,m,u,h,f,x,g,y,v;if(o=r.vertices[0],s=r.vertices[1],i=r.vertices[2],n=r.vertices[3],l=r.normals[0],c=r.normals[1],d=r.normals[2],p=r.normals[3],r.vertexColors&&(m=this._createColor(r.vertexColors[0]),u=this._createColor(r.vertexColors[1]),h=this._createColor(r.vertexColors[2]),f=this._createColor(r.vertexColors[3])),a.uvs&&(x=r.uv[0]??{u:0,v:0},g=r.uv[1]??{u:0,v:0},y=r.uv[2]??{u:0,v:0},v=r.uv[3]??{u:0,v:0}),"back"===t.color.material.side){let e;e=o,o=i,i=e,e=l,l=d,d=e,e=m,m=h,h=e,e=x,x=y,y=e}if(a.positions.push(i.x,i.y,i.z),a.positions.push(s.x,s.y,s.z),a.positions.push(o.x,o.y,o.z),a.positions.push(o.x,o.y,o.z),a.positions.push(n.x,n.y,n.z),a.positions.push(i.x,i.y,i.z),t.material.lighting===SVOX.SMOOTH||t.material.lighting===SVOX.SIDES||t.material.lighting===SVOX.BOTH&&r.smooth)a.normals.push(d.x,d.y,d.z),a.normals.push(c.x,c.y,c.z),a.normals.push(l.x,l.y,l.z),a.normals.push(l.x,l.y,l.z),a.normals.push(p.x,p.y,p.z),a.normals.push(d.x,d.y,d.z);else{let r=e._normalize({x:d.x+c.x+l.x,y:d.y+c.y+l.y,z:d.z+c.z+l.z}),o=e._normalize({x:l.x+p.x+d.x,y:l.y+p.y+d.y,z:l.z+p.z+d.z});t.material.lighting===SVOX.QUAD&&(r=e._normalize({x:r.x+o.x,y:r.y+o.y,z:r.z+o.z}),o=r),a.normals.push(r.x,r.y,r.z),a.normals.push(r.x,r.y,r.z),a.normals.push(r.x,r.y,r.z),a.normals.push(o.x,o.y,o.z),a.normals.push(o.x,o.y,o.z),a.normals.push(o.x,o.y,o.z)}if(r.vertexColors)SVOX.clampColors&&(this._clampColor(m),this._clampColor(u),this._clampColor(h),this._clampColor(f)),a.colors.push(h.r,h.g,h.b),a.colors.push(u.r,u.g,u.b),a.colors.push(m.r,m.g,m.b),a.colors.push(m.r,m.g,m.b),a.colors.push(f.r,f.g,f.b),a.colors.push(h.r,h.g,h.b);else{m=r.color?this._createColor(r.color):this._createColor(t.color);for(let e=0;e<6;e++)a.colors.push(m.r,m.g,m.b)}if(a.uvs&&(a.uvs.push(y.u,y.v),a.uvs.push(g.u,g.v),a.uvs.push(x.u,x.v),a.uvs.push(x.u,x.v),a.uvs.push(v.u,v.v),a.uvs.push(y.u,y.v)),a.data){let r=t.material.data??e.data;for(let e=0;e<6;e++)for(let e=0;e<r.length;e++)for(let t=0;t<r[e].values.length;t++)a.data[e].values.push(r[e].values[t])}}static _clampColor(e){e.r=Math.max(e.r,0),e.g=Math.max(e.g,0),e.b=Math.max(e.b,0),e.r=Math.min(e.r,1),e.g=Math.min(e.g,1),e.b=Math.min(e.b,1)}static _getAllShells(e){let t=[];return e.materials.forEach((function(r){let a;e.shell&&e.shell.length>0&&!r.shell&&(a=e.shell),r.shell&&r.shell.length>0&&(a=r.shell),a&&a.forEach((function(e){t.push({material:e.color.material,voxelMaterial:r,side:e.color.material.side,color:this._createColor(e.color),lighting:e.color.material.lighting,distance:e.distance})}),this)}),this),t.sort((function(e,t){e.material.index,t.material.index})),t}static _generateVoxelShell(e,t,r,a){for(let o=0;o<SVOX._FACES.length;o++){let s=t.faces[SVOX._FACES[o]];s&&SvoxMeshGenerator._generateVoxelShellFace(e,t,s,r,a)}}static _generateVoxelShellFace(e,t,r,a,o){let s,i,n,l,c,d,p,m,u,h,f,x,g,y,v,b;s=r.vertices[0],i=r.vertices[1],n=r.vertices[2],l=r.vertices[3],c=s.smoothNormal,d=i.smoothNormal,p=n.smoothNormal,m=l.smoothNormal;let z=null;switch(o.lighting){case SVOX.SMOOTH:z=r.smoothNormals;break;case SVOX.BOTH:z=r.bothNormals;break;case SVOX.SIDES:z=r.sideNormals;break;default:z=r.flatNormals}if(u=z[0],h=z[1],f=z[2],x=z[3],a.uvs&&(g=r.uv[0]??{u:1e-4,v:1e-4},y=r.uv[1]??{u:1e-4,v:.9999},v=r.uv[2]??{u:.9999,v:.9999},b=r.uv[3]??{u:.9999,v:1e-4}),"back"===o.side){let e;e=s,s=n,n=e,e=u,u=f,f=e,e=c,c=p,p=e,e=g,g=v,v=e}let w=s.x+c.x*o.distance*e.scale.x,M=s.y+c.y*o.distance*e.scale.y,S=s.z+c.z*o.distance*e.scale.z,_=i.x+d.x*o.distance*e.scale.x,P=i.y+d.y*o.distance*e.scale.y,E=i.z+d.z*o.distance*e.scale.z,F=n.x+p.x*o.distance*e.scale.x,X=n.y+p.y*o.distance*e.scale.y,N=n.z+p.z*o.distance*e.scale.z,A=l.x+m.x*o.distance*e.scale.x,I=l.y+m.y*o.distance*e.scale.y,T=l.z+m.z*o.distance*e.scale.z;if(a.positions.push(F,X,N),a.positions.push(_,P,E),a.positions.push(w,M,S),a.positions.push(w,M,S),a.positions.push(A,I,T),a.positions.push(F,X,N),o.lighting===SVOX.SMOOTH||o.lighting===SVOX.SIDES||o.lighting===SVOX.BOTH&&r.smooth)a.normals.push(f.x,f.y,f.z),a.normals.push(h.x,h.y,h.z),a.normals.push(u.x,u.y,u.z),a.normals.push(u.x,u.y,u.z),a.normals.push(x.x,x.y,x.z),a.normals.push(f.x,f.y,f.z);else{let r=e._normalize({x:f.x+h.x+u.x,y:f.y+h.y+u.y,z:f.z+h.z+u.z}),o=e._normalize({x:u.x+x.x+f.x,y:u.y+x.y+f.y,z:u.z+x.z+f.z});t.material.lighting===SVOX.QUAD&&(r=e._normalize({x:r.x+o.x,y:r.y+o.y,z:r.z+o.z}),o=r),a.normals.push(r.x,r.y,r.z),a.normals.push(r.x,r.y,r.z),a.normals.push(r.x,r.y,r.z),a.normals.push(o.x,o.y,o.z),a.normals.push(o.x,o.y,o.z),a.normals.push(o.x,o.y,o.z)}for(let e=0;e<6;e++)a.colors.push(o.color.r,o.color.g,o.color.b);if(a.uvs&&(a.uvs.push(v.u,v.v),a.uvs.push(y.u,y.v),a.uvs.push(g.u,g.v),a.uvs.push(g.u,g.v),a.uvs.push(b.u,b.v),a.uvs.push(v.u,v.v)),a.data){let t=o.material.data??e.data;for(let e=0;e<6;e++)for(let e=0;e<t.length;e++)for(let r=0;r<t[e].values.length;r++)a.data[e].values.push(t[e].values[r])}}static _normalize(e){let t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);return e.x/=t,e.y/=t,e.z/=t,e}static _createColor(e){return e?{hex:e.toString(),r:SVOX.colorManagement?this._SRGBToLinear(e.r):e.r,g:SVOX.colorManagement?this._SRGBToLinear(e.g):e.g,b:SVOX.colorManagement?this._SRGBToLinear(e.b):e.b}:void 0}static _SRGBToLinear(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}}class SvoxToThreeMeshConverter{static generate(e){let t=[];e.materials.forEach((function(e){t.push(SvoxToThreeMeshConverter._generatethreeMaterial(e))}),this);let r=new THREE.BufferGeometry;if(r.setAttribute("position",new THREE.BufferAttribute(e.positions,3)),r.setAttribute("normal",new THREE.BufferAttribute(e.normals,3)),e.colors&&r.setAttribute("color",new THREE.BufferAttribute(e.colors,3)),e.uvs&&r.setAttribute("uv",new THREE.BufferAttribute(e.uvs,2)),e.data)for(let t=0;t<e.data.length;t++)r.setAttribute(e.data[t].name,new THREE.BufferAttribute(e.data[t].values,e.data[t].width));r.setIndex(new THREE.BufferAttribute(e.indices,1)),e.groups.forEach((function(e){r.addGroup(e.start,e.count,e.materialIndex)}),this),r.computeBoundingBox(),r.uvsNeedUpdate=!0;let a=new THREE.Mesh(r,t);return SVOX.showNormals&&THREE.VertexNormalsHelper?new THREE.VertexNormalsHelper(a,.1):a}static _generatethreeMaterial(e){switch((e="function"==typeof structuredClone?structuredClone(e):JSON.parse(JSON.stringify(e))).side){case"front":e.side=THREE.FrontSide;break;case"back":e.side=THREE.BackSide;break;case"double":e.side=THREE.DoubleSide;break;default:throw{name:"RenderError",message:`Unknown side value '${e.side}'.`}}if(e.shadowSide)switch(e.shadowSide){case"front":e.shadowSide=THREE.FrontSide;break;case"back":e.shadowSide=THREE.BackSide;break;case"double":e.shadowSide=THREE.DoubleSide;break;default:throw{name:"RenderError",message:`Unknown shadowside value '${e.side}'.`}}switch(e.combine){case"multiply":e.combine=THREE.MultiplyOperation;break;case"mix":e.combine=THREE.MixOperation;break;case"add":e.combine=THREE.AddOperation;break;case void 0:break;default:throw{name:"RenderError",message:`Unknown combine value '${e.combine}'.`}}switch(e.blending){case"no":e.blending=THREE.NoBlending;break;case"normal":e.blending=THREE.NormalBlending;break;case"additive":e.blending=THREE.AdditiveBlending;break;case"subtractive":e.blending=THREE.SubtractiveBlending;break;case"multiply":e.blending=THREE.MultiplyBlending;break;case void 0:break;default:throw{name:"RenderError",message:`Unknown blending value '${e.blending}'.`}}for(const t in e){let r=e[t];r&&"object"==typeof r&&"r"in r&&"g"in r&&"b"in r&&(e[t]=new THREE.Color(r.r,r.g,r.b))}e.normalScale&&(e.normalScale=new THREE.Vector2(e.normalScale.x,e.normalScale.y));for(const t in e)void 0!==e[t]&&("envMap"===t?(e.envMap=(new THREE.TextureLoader).load(e.envMap.image),e.envMap.colorSpace=THREE.SRGBColorSpace,e.ior||e.refractionRatio?e.envMap.mapping=THREE.EquirectangularRefractionMapping:e.envMap.mapping=THREE.EquirectangularReflectionMapping):"matcap"===t?e.matcap=SvoxToThreeMeshConverter._generateTexture(e.matcap.image,THREE.SRGBColorSpace):["map","emissiveMap","specularColorMap"].includes(t)?e[t]=SvoxToThreeMeshConverter._generateTexture(e[t].image,THREE.SRGBColorSpace,e[t].uscale,e[t].vscale,e[t].uoffset,e[t].voffset,e[t].rotation):t.endsWith("Map")&&(e[t]=SvoxToThreeMeshConverter._generateTexture(e[t].image,THREE.LinearSRGBColorSpace,e[t].uscale,e[t].vscale,e[t].uoffset,e[t].voffset,e[t].rotation)));let t=null,r=e.type;delete e.index,delete e.type;for(const t in e)(void 0===e[t]||SVOX.MATERIALDEFINITIONS[t]&&!SVOX.MATERIALDEFINITIONS[t][r])&&delete e[t];switch(r){case"standard":t=new THREE.MeshStandardMaterial(e);break;case"basic":t=new THREE.MeshBasicMaterial(e);break;case"lambert":t=new THREE.MeshLambertMaterial(e);break;case"phong":t=new THREE.MeshPhongMaterial(e);break;case"physical":t=new THREE.MeshPhysicalMaterial(e);break;case"matcap":t=new THREE.MeshMatcapMaterial(e);break;case"toon":t=new THREE.MeshToonMaterial(e);break;case"normal":t=new THREE.MeshNormalMaterial(e);break;default:throw{name:"SyntaxError",message:`Unknown tmaterial type '${r}'.`}}return t}static _generateTexture(e,t,r,a,o,s,i){let n=(new THREE.TextureLoader).load(e);return n.colorSpace=t,n.repeat.set(1/r,1/a),n.wrapS=THREE.RepeatWrapping,n.wrapT=THREE.RepeatWrapping,n.offset=new THREE.Vector2(o,s),n.rotation=i*Math.PI/180,n}}const workerScript="\n\ntry {\n  importScripts('https://cdn.jsdelivr.net/gh/SamuelVanEgmond/Smooth-Voxels@v2.2.0/dist/smoothvoxels.min.js');\n}\ncatch {\n  // For local development before the actual release \n  importScripts(location.origin + '/smoothvoxels.js');\n}\n\nonmessage = function(event) {\n  try {\n    let svoxmesh = generateModel(event.data.svoxModel, event.data.modelName);\n  \n    let transferables = [ svoxmesh.indices.buffer, svoxmesh.positions.buffer, svoxmesh.normals.buffer ];\n    if (svoxmesh.colors)\n      transferables.push(svoxmesh.colors.buffer);\n    if (svoxmesh.uvs)\n      transferables.push(svoxmesh.uvs.buffer);\n    if (svoxmesh.data) {\n      for (let d=0;d<svoxmesh.data.length;d++) {\n          let data = svoxmesh.data[d];\n          transferables.push(data.values.buffer);\n      }\n    }\n\n    postMessage( { svoxmesh, elementId:event.data.elementId, worker:event.data.worker } , transferables);\n  }\n  catch (err) {\n    SVOX.logError(err);\n  }\n};\n\n\nfunction generateModel(svoxModel, modelName) {\n  let _MISSING = \"model size=9,scale=0.05,material lighting=flat,colors=B:#FF8800 C:#FF0000 A:#FFFFFF,voxels 10B7-2(2B2-3C2-2B4-C2-)2B2-3C2-2B7-11B7-B-6(7A2-)7A-B7-2B2-3C2-B-6(7A2-)7A-B2-3C2-2B2-C4-B-2(7A-C7A2C)7A-C7AC-7A-B2-C4-2B2-3C2-B3(-7A-C7AC)-7A-B2-3C2-2B2-C4-B-7A-C2(7AC-7A2C)7AC-7A-B2-C4-2B2-3C2-B-6(7A2-)7A-B2-3C2-2B7-B-6(7A2-)7A-B7-11B7-2(2B2-3C2-2B2-C4-)2B2-3C2-2B7-10B\";\n  let _ERROR   = \"model size=9,scale=0.05,material lighting=flat,colors=A:#FFFFFF B:#FF8800 C:#FF0000,voxels 10B7-2B-C3-C-2B2-C-C2-2B3-C3-2B2-C-C2-2B-C3-C-2B7-11B7-B-6(7A2-)7A-B7-2B-C3-C-B-7A-C7AC-2(7A2-)7A-C7AC-7A-B-C3-C-2B2-C-C2-B-7A2-2(7A-C7AC-)7A2-7A-B2-C-C2-2B3-C3-B-2(7A2-)7A-C7AC-2(7A2-)7A-B3-C3-2B2-C-C2-B-7A2-2(7A-C7AC-)7A2-7A-B2-C-C2-2B-C3-C-B-7A-C7AC-2(7A2-)7A-C7AC-7A-B-C3-C-2B7-B-6(7A2-)7A-B7-11B7-2B-C3-C-2B2-C-C2-2B3-C3-2B2-C-C2-2B-C3-C-2B7-10B\";\n\n  let error = undefined;\n  if (!svoxModel || svoxModel.trim() === '') {\n    error = { name:'ConfigError', message:'Model not found' };\n    svoxModel = _MISSING;\n  }\n\n  let model = null;\n  try {        \n      model = ModelReader.readFromString(svoxModel, modelName);\n  }\n  catch (err) {\n    error = err;\n    model = ModelReader.readFromString(_ERROR);\n  }\n  \n  let svoxmesh = SvoxMeshGenerator.generate(model, modelName);\n  svoxmesh.error = error;\n  \n  return svoxmesh;\n}\n";var workerUrl=URL.createObjectURL(new Blob([workerScript],{type:"application/javascript"}));class WorkerPool{constructor(e,t,r){this._workerFile=e,this._resultHandler=t,this._resultCallback=r,this._nrOfWorkers=window.navigator.hardwareConcurrency,this._workers=[],this._free=[],this._tasks=[]}executeTask(e){if(this._workers.length<this._nrOfWorkers){let e=new Worker(this._workerFile),t=this;e.onmessage=function(e){t._free.push(event.data.worker),t._processNextTask(),t._resultCallback.apply(t._resultHandler,[event.data])},this._free.push(this._workers.length),this._workers.push(e)}this._tasks.push(e),this._processNextTask()}_processNextTask(){if(this._tasks.length>0&&this._free.length>0){let e=this._tasks.shift();e.worker=this._free.shift(),this._workers[e.worker].postMessage(e)}}}if("undefined"!=typeof window){if("undefined"==typeof AFRAME)throw new Error("Component attempted to register before AFRAME was available.");SVOX.WORKERPOOL=null,AFRAME.registerComponent("svox",{schema:{model:{type:"string"},worker:{type:"boolean",default:!1}},multiple:!1,_ERROR:"model size=9,scale=0.05\nlight intensity=0.8\nlight direction=1 1 0,intensity=0.4\nmaterial type=basic,lighting=flat,colors=A:#FFF B:#F80,ao=0.1 0.5\ngroup id=cross,prefab=true,scale= 1 0.5 1\nmaterial type=basic,lighting=flat,colors=C:#F00,group=cross\ngroup id=nx, clone=cross,rotation=0 45 90,position=-4 0 0\ngroup id=px, clone=cross,rotation=0 45 90,position=4 0 0\ngroup id=ny, clone=cross,rotation=0 45 0,position=0 -4 0\ngroup id=py, clone=cross,rotation=0 45 0,position=0 4 0\ngroup id=nz, clone=cross,rotation=90 0 45,position=0 0 -4\ngroup id=pz, clone=cross,rotation=90 0 45,position=0 0 4\nvoxels 10B6(7-2B)7-11B7-B-6(7A2-)7A-B7-2(2B7-B-6(7A2-)7A-B3-C3-)2B7-B-6(7A2-)7A-B-5C-2(2B7-B-6(7A2-)7A-B3-C3-)2B7-B-6(7A2-)7A-B7-11B6(7-2B)7-10B",_MISSING:"model size=9 10 9,scale=0.05\nlight intensity=0.8\nlight direction=1 1 0,intensity=0.4\nmaterial type=basic,lighting=flat,colors=A:#FFF B:#F80,ao=0.1 0.5\ngroup id=questionmark,prefab=true,scale=0.5 0.5 0.6\nmaterial type=basic,lighting=both,colors=C:#F00,deform=1,clamp=y,group=questionmark\ngroup id=nx,clone=questionmark,rotation=0 -90 90,position=-4 0 0\ngroup id=px,clone=questionmark,rotation=0 90 -90,position=4 0 0\ngroup id=ny,clone=questionmark,rotation=180 0 0,position=0 -4 0\ngroup id=py,clone=questionmark,rotation=0 0 0,position=0 4 0\ngroup id=nz,clone=questionmark,rotation=90 180 0,position=0 0 -4\ngroup id=pz,clone=questionmark,rotation=90 0 0,position=0 0 4\nvoxels 10B6(7-2B)7-10B2-4C3-2(B7-B-6(7A2-)7A-B7-B-2(2C2-))B7-B-6(7A2-)7A-B7-B4-2C3-2(B7-B-6(7A2-)7A-B7-B3-2C4-)B7-B-6(7A2-)7A-B7-B9-B7-B-6(7A2-)7A-B7-B3-2C4-10B6(7-2B)7-10B3-2C4-",_workerPool:null,init:function(){let e=this.el,t=this.data,r=t.worker,a=!1,o=t.model,s=SVOX.models[o];s||(SVOX.logError({name:"ConfigError",message:`(${o}) Model ${o} not found`}),s=this._MISSING,o="_MISSING",a=!0,r=!1),r?this._generateModelInWorker(s,o,e):this._generateModel(s,o,e,a)},_generateModel:function(e,t,r,a){let o,s=performance.now();try{o=ModelReader.readFromString(e,t)}catch(e){SVOX.logError(e),o=ModelReader.readFromString(this._ERROR,"_ERROR"),a=!0}try{let e=SvoxMeshGenerator.generate(o);this.mesh=SvoxToThreeMeshConverter.generate(e);let t=performance.now(),i=`Voxels: ${o.voxels.count}  Time: ${Math.round(t-s)/1e3}s. Verts:${(e.positions.length/3).toLocaleString()} Faces:${(e.indices.length/3).toLocaleString()} Materials:${this.mesh.material.length}`,n=document.getElementById("svoxstats");n&&!a&&(n.innerHTML="Last render: "+i),r.setObject3D("mesh",this.mesh)}catch(a){SVOX.logError(a)}},_generateModelInWorker:function(e,t,r){r.id||(r.id=(new Date).valueOf().toString(36)+Math.random().toString(36).substr(2));let a={svoxModel:e,modelName:t,elementId:r.id};SVOX.WORKERPOOL||(SVOX.WORKERPOOL=new WorkerPool(workerUrl,this,this._processResult)),SVOX.WORKERPOOL.executeTask(a)},_processResult:function(e){if(e.svoxmesh.error)SVOX.logError(e.svoxmesh.error);else{let t=SvoxToThreeMeshConverter.generate(e.svoxmesh);document.querySelector("#"+e.elementId).setObject3D("mesh",t)}},_toSharedArrayBuffer(e){let t=new Float32Array(new ArrayBuffer(4*e.length));return t.set(e,0),t},update:function(e){},remove:function(){let e=["map","normalMap","roughnessMap","metalnessMap","emissiveMap","matcap"];if(this.mesh){if(Array.isArray(this.mesh.material))for(;this.mesh.material.length>0;)e.forEach((function(e){this.mesh.material[0][e]&&this.mesh.material[0][e].dispose}),this),this.mesh.material[0].dispose(),this.mesh.material.shift();else this.mesh.material.dispose();this.mesh.geometry.dispose(),this.el.removeObject3D("mesh"),delete this.mesh}},pause:function(){},play:function(){},events:{}})}
//# sourceMappingURL=/sm/2834b907459d8042f76d384b6b3ddcfb87f6dd4d2bb491ec2facb9febb8646f2.map